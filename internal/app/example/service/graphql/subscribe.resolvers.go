package graphql

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"os"
	"time"

	"github.com/99designs/gqlgen/graphql/handler/transport"
	"github.com/go-keg/monorepo/internal/app/example/service/graphql/model"
	jwt "github.com/golang-jwt/jwt/v5"
	"github.com/spf13/cast"
)

// SendMessage is the resolver for the sendMessage field.
func (r *mutationResolver) SendMessage(ctx context.Context, input model.SendMessageInput) (*model.Message, error) {
	msg := &model.Message{
		ID:          int(time.Now().Unix()),
		Sender:      input.Sender,
		Type:        input.Type,
		Content:     input.Content,
		ContentType: input.ContentType,
		Metadata:    input.Metadata,
		CreatedAt:   time.Now(),
	}
	r.pubSub.Publish(msg)
	return msg, nil
}

// MessageReceived is the resolver for the messageReceived field.
func (r *subscriptionResolver) MessageReceived(ctx context.Context) (<-chan *model.Message, error) {
	payload := transport.GetInitPayload(ctx)
	var accountID int
	if v, ok := payload["X-ACCOUNT-ID"]; ok && os.Getenv("APP_ENV") == "local" {
		accountID = cast.ToInt(v)
	} else {
		token := payload.Authorization()
		claims, err := jwt.Parse(token, func(token *jwt.Token) (interface{}, error) {
			return os.Getenv("APP_KEY"), nil
		})
		if err == nil {
			subject, _ := claims.Claims.GetSubject()
			accountID = cast.ToInt(subject)
		}
	}

	msgCh := make(chan *model.Message, 8)
	sub := r.pubSub.Subscribe(accountID)

	go func() {
		<-ctx.Done()
		r.pubSub.Unsubscribe(sub)
	}()

	go func() {
		for m := range sub {
			msgCh <- m
		}
	}()

	return msgCh, nil
}

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type subscriptionResolver struct{ *Resolver }
