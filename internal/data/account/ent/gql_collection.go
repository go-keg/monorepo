// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/go-keg/monorepo/internal/data/account/ent/membership"
	"github.com/go-keg/monorepo/internal/data/account/ent/oauthaccount"
	"github.com/go-keg/monorepo/internal/data/account/ent/oauthprovider"
	"github.com/go-keg/monorepo/internal/data/account/ent/organization"
	"github.com/go-keg/monorepo/internal/data/account/ent/permission"
	"github.com/go-keg/monorepo/internal/data/account/ent/tenant"
	"github.com/go-keg/monorepo/internal/data/account/ent/tenantrole"
	"github.com/go-keg/monorepo/internal/data/account/ent/tenantuser"
	"github.com/go-keg/monorepo/internal/data/account/ent/user"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (mq *MembershipQuery) CollectFields(ctx context.Context, satisfies ...string) (*MembershipQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return mq, nil
	}
	if err := mq.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return mq, nil
}

func (mq *MembershipQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(membership.Columns))
		selectedFields = []string{membership.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenantUser":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantUserClient{config: mq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantuserImplementors)...); err != nil {
				return err
			}
			mq.withTenantUser = query
			if _, ok := fieldSeen[membership.FieldTenantUserID]; !ok {
				selectedFields = append(selectedFields, membership.FieldTenantUserID)
				fieldSeen[membership.FieldTenantUserID] = struct{}{}
			}

		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: mq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			mq.withOrganization = query
			if _, ok := fieldSeen[membership.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, membership.FieldOrganizationID)
				fieldSeen[membership.FieldOrganizationID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[membership.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, membership.FieldCreatedAt)
				fieldSeen[membership.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[membership.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, membership.FieldUpdatedAt)
				fieldSeen[membership.FieldUpdatedAt] = struct{}{}
			}
		case "organizationID":
			if _, ok := fieldSeen[membership.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, membership.FieldOrganizationID)
				fieldSeen[membership.FieldOrganizationID] = struct{}{}
			}
		case "tenantUserID":
			if _, ok := fieldSeen[membership.FieldTenantUserID]; !ok {
				selectedFields = append(selectedFields, membership.FieldTenantUserID)
				fieldSeen[membership.FieldTenantUserID] = struct{}{}
			}
		case "isLeader":
			if _, ok := fieldSeen[membership.FieldIsLeader]; !ok {
				selectedFields = append(selectedFields, membership.FieldIsLeader)
				fieldSeen[membership.FieldIsLeader] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		mq.Select(selectedFields...)
	}
	return nil
}

type membershipPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []MembershipPaginateOption
}

func newMembershipPaginateArgs(rv map[string]any) *membershipPaginateArgs {
	args := &membershipPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &MembershipOrder{Field: &MembershipOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithMembershipOrder(order))
			}
		case *MembershipOrder:
			if v != nil {
				args.opts = append(args.opts, WithMembershipOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*MembershipWhereInput); ok {
		args.opts = append(args.opts, WithMembershipFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (oaq *OAuthAccountQuery) CollectFields(ctx context.Context, satisfies ...string) (*OAuthAccountQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return oaq, nil
	}
	if err := oaq.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return oaq, nil
}

func (oaq *OAuthAccountQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(oauthaccount.Columns))
		selectedFields = []string{oauthaccount.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: oaq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			oaq.withUser = query
			if _, ok := fieldSeen[oauthaccount.FieldUserID]; !ok {
				selectedFields = append(selectedFields, oauthaccount.FieldUserID)
				fieldSeen[oauthaccount.FieldUserID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[oauthaccount.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, oauthaccount.FieldCreatedAt)
				fieldSeen[oauthaccount.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[oauthaccount.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, oauthaccount.FieldUpdatedAt)
				fieldSeen[oauthaccount.FieldUpdatedAt] = struct{}{}
			}
		case "userID":
			if _, ok := fieldSeen[oauthaccount.FieldUserID]; !ok {
				selectedFields = append(selectedFields, oauthaccount.FieldUserID)
				fieldSeen[oauthaccount.FieldUserID] = struct{}{}
			}
		case "provider":
			if _, ok := fieldSeen[oauthaccount.FieldProvider]; !ok {
				selectedFields = append(selectedFields, oauthaccount.FieldProvider)
				fieldSeen[oauthaccount.FieldProvider] = struct{}{}
			}
		case "providerUserID":
			if _, ok := fieldSeen[oauthaccount.FieldProviderUserID]; !ok {
				selectedFields = append(selectedFields, oauthaccount.FieldProviderUserID)
				fieldSeen[oauthaccount.FieldProviderUserID] = struct{}{}
			}
		case "accessToken":
			if _, ok := fieldSeen[oauthaccount.FieldAccessToken]; !ok {
				selectedFields = append(selectedFields, oauthaccount.FieldAccessToken)
				fieldSeen[oauthaccount.FieldAccessToken] = struct{}{}
			}
		case "refreshToken":
			if _, ok := fieldSeen[oauthaccount.FieldRefreshToken]; !ok {
				selectedFields = append(selectedFields, oauthaccount.FieldRefreshToken)
				fieldSeen[oauthaccount.FieldRefreshToken] = struct{}{}
			}
		case "tokenExpiry":
			if _, ok := fieldSeen[oauthaccount.FieldTokenExpiry]; !ok {
				selectedFields = append(selectedFields, oauthaccount.FieldTokenExpiry)
				fieldSeen[oauthaccount.FieldTokenExpiry] = struct{}{}
			}
		case "profile":
			if _, ok := fieldSeen[oauthaccount.FieldProfile]; !ok {
				selectedFields = append(selectedFields, oauthaccount.FieldProfile)
				fieldSeen[oauthaccount.FieldProfile] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		oaq.Select(selectedFields...)
	}
	return nil
}

type oauthaccountPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OAuthAccountPaginateOption
}

func newOAuthAccountPaginateArgs(rv map[string]any) *oauthaccountPaginateArgs {
	args := &oauthaccountPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &OAuthAccountOrder{Field: &OAuthAccountOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithOAuthAccountOrder(order))
			}
		case *OAuthAccountOrder:
			if v != nil {
				args.opts = append(args.opts, WithOAuthAccountOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*OAuthAccountWhereInput); ok {
		args.opts = append(args.opts, WithOAuthAccountFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (opq *OAuthProviderQuery) CollectFields(ctx context.Context, satisfies ...string) (*OAuthProviderQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return opq, nil
	}
	if err := opq.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return opq, nil
}

func (opq *OAuthProviderQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(oauthprovider.Columns))
		selectedFields = []string{oauthprovider.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "provider":
			if _, ok := fieldSeen[oauthprovider.FieldProvider]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldProvider)
				fieldSeen[oauthprovider.FieldProvider] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[oauthprovider.FieldName]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldName)
				fieldSeen[oauthprovider.FieldName] = struct{}{}
			}
		case "clientID":
			if _, ok := fieldSeen[oauthprovider.FieldClientID]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldClientID)
				fieldSeen[oauthprovider.FieldClientID] = struct{}{}
			}
		case "authURL":
			if _, ok := fieldSeen[oauthprovider.FieldAuthURL]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldAuthURL)
				fieldSeen[oauthprovider.FieldAuthURL] = struct{}{}
			}
		case "tokenURL":
			if _, ok := fieldSeen[oauthprovider.FieldTokenURL]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldTokenURL)
				fieldSeen[oauthprovider.FieldTokenURL] = struct{}{}
			}
		case "userInfoURL":
			if _, ok := fieldSeen[oauthprovider.FieldUserInfoURL]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldUserInfoURL)
				fieldSeen[oauthprovider.FieldUserInfoURL] = struct{}{}
			}
		case "redirectURI":
			if _, ok := fieldSeen[oauthprovider.FieldRedirectURI]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldRedirectURI)
				fieldSeen[oauthprovider.FieldRedirectURI] = struct{}{}
			}
		case "scopes":
			if _, ok := fieldSeen[oauthprovider.FieldScopes]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldScopes)
				fieldSeen[oauthprovider.FieldScopes] = struct{}{}
			}
		case "enabled":
			if _, ok := fieldSeen[oauthprovider.FieldEnabled]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldEnabled)
				fieldSeen[oauthprovider.FieldEnabled] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		opq.Select(selectedFields...)
	}
	return nil
}

type oauthproviderPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OAuthProviderPaginateOption
}

func newOAuthProviderPaginateArgs(rv map[string]any) *oauthproviderPaginateArgs {
	args := &oauthproviderPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*OAuthProviderWhereInput); ok {
		args.opts = append(args.opts, WithOAuthProviderFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (oq *OrganizationQuery) CollectFields(ctx context.Context, satisfies ...string) (*OrganizationQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return oq, nil
	}
	if err := oq.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return oq, nil
}

func (oq *OrganizationQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(organization.Columns))
		selectedFields = []string{organization.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "parent":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: oq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			oq.withParent = query
			if _, ok := fieldSeen[organization.FieldParentID]; !ok {
				selectedFields = append(selectedFields, organization.FieldParentID)
				fieldSeen[organization.FieldParentID] = struct{}{}
			}

		case "children":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: oq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			oq.WithNamedChildren(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})

		case "memberships":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MembershipClient{config: oq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, membershipImplementors)...); err != nil {
				return err
			}
			oq.WithNamedMemberships(alias, func(wq *MembershipQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[organization.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, organization.FieldCreatedAt)
				fieldSeen[organization.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[organization.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, organization.FieldUpdatedAt)
				fieldSeen[organization.FieldUpdatedAt] = struct{}{}
			}
		case "tenantID":
			if _, ok := fieldSeen[organization.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, organization.FieldTenantID)
				fieldSeen[organization.FieldTenantID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[organization.FieldName]; !ok {
				selectedFields = append(selectedFields, organization.FieldName)
				fieldSeen[organization.FieldName] = struct{}{}
			}
		case "parentID":
			if _, ok := fieldSeen[organization.FieldParentID]; !ok {
				selectedFields = append(selectedFields, organization.FieldParentID)
				fieldSeen[organization.FieldParentID] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[organization.FieldType]; !ok {
				selectedFields = append(selectedFields, organization.FieldType)
				fieldSeen[organization.FieldType] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		oq.Select(selectedFields...)
	}
	return nil
}

type organizationPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OrganizationPaginateOption
}

func newOrganizationPaginateArgs(rv map[string]any) *organizationPaginateArgs {
	args := &organizationPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &OrganizationOrder{Field: &OrganizationOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithOrganizationOrder(order))
			}
		case *OrganizationOrder:
			if v != nil {
				args.opts = append(args.opts, WithOrganizationOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*OrganizationWhereInput); ok {
		args.opts = append(args.opts, WithOrganizationFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pq *PermissionQuery) CollectFields(ctx context.Context, satisfies ...string) (*PermissionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pq, nil
	}
	if err := pq.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pq, nil
}

func (pq *PermissionQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(permission.Columns))
		selectedFields = []string{permission.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "parent":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PermissionClient{config: pq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, permissionImplementors)...); err != nil {
				return err
			}
			pq.withParent = query
			if _, ok := fieldSeen[permission.FieldParentID]; !ok {
				selectedFields = append(selectedFields, permission.FieldParentID)
				fieldSeen[permission.FieldParentID] = struct{}{}
			}

		case "children":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PermissionClient{config: pq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, permissionImplementors)...); err != nil {
				return err
			}
			pq.WithNamedChildren(alias, func(wq *PermissionQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[permission.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, permission.FieldCreatedAt)
				fieldSeen[permission.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[permission.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, permission.FieldUpdatedAt)
				fieldSeen[permission.FieldUpdatedAt] = struct{}{}
			}
		case "parentID":
			if _, ok := fieldSeen[permission.FieldParentID]; !ok {
				selectedFields = append(selectedFields, permission.FieldParentID)
				fieldSeen[permission.FieldParentID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[permission.FieldName]; !ok {
				selectedFields = append(selectedFields, permission.FieldName)
				fieldSeen[permission.FieldName] = struct{}{}
			}
		case "key":
			if _, ok := fieldSeen[permission.FieldKey]; !ok {
				selectedFields = append(selectedFields, permission.FieldKey)
				fieldSeen[permission.FieldKey] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[permission.FieldType]; !ok {
				selectedFields = append(selectedFields, permission.FieldType)
				fieldSeen[permission.FieldType] = struct{}{}
			}
		case "path":
			if _, ok := fieldSeen[permission.FieldPath]; !ok {
				selectedFields = append(selectedFields, permission.FieldPath)
				fieldSeen[permission.FieldPath] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[permission.FieldDescription]; !ok {
				selectedFields = append(selectedFields, permission.FieldDescription)
				fieldSeen[permission.FieldDescription] = struct{}{}
			}
		case "sort":
			if _, ok := fieldSeen[permission.FieldSort]; !ok {
				selectedFields = append(selectedFields, permission.FieldSort)
				fieldSeen[permission.FieldSort] = struct{}{}
			}
		case "attrs":
			if _, ok := fieldSeen[permission.FieldAttrs]; !ok {
				selectedFields = append(selectedFields, permission.FieldAttrs)
				fieldSeen[permission.FieldAttrs] = struct{}{}
			}
		case "isSystem":
			if _, ok := fieldSeen[permission.FieldIsSystem]; !ok {
				selectedFields = append(selectedFields, permission.FieldIsSystem)
				fieldSeen[permission.FieldIsSystem] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pq.Select(selectedFields...)
	}
	return nil
}

type permissionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PermissionPaginateOption
}

func newPermissionPaginateArgs(rv map[string]any) *permissionPaginateArgs {
	args := &permissionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &PermissionOrder{Field: &PermissionOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithPermissionOrder(order))
			}
		case *PermissionOrder:
			if v != nil {
				args.opts = append(args.opts, WithPermissionOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*PermissionWhereInput); ok {
		args.opts = append(args.opts, WithPermissionFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (tq *TenantQuery) CollectFields(ctx context.Context, satisfies ...string) (*TenantQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return tq, nil
	}
	if err := tq.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return tq, nil
}

func (tq *TenantQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(tenant.Columns))
		selectedFields = []string{tenant.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenantUsers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantUserClient{config: tq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, tenantuserImplementors)...); err != nil {
				return err
			}
			tq.WithNamedTenantUsers(alias, func(wq *TenantUserQuery) {
				*wq = *query
			})

		case "roles":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantRoleClient{config: tq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, tenantroleImplementors)...); err != nil {
				return err
			}
			tq.WithNamedRoles(alias, func(wq *TenantRoleQuery) {
				*wq = *query
			})

		case "organizations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: tq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			tq.WithNamedOrganizations(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[tenant.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, tenant.FieldCreatedAt)
				fieldSeen[tenant.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[tenant.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, tenant.FieldUpdatedAt)
				fieldSeen[tenant.FieldUpdatedAt] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[tenant.FieldName]; !ok {
				selectedFields = append(selectedFields, tenant.FieldName)
				fieldSeen[tenant.FieldName] = struct{}{}
			}
		case "maxUsers":
			if _, ok := fieldSeen[tenant.FieldMaxUsers]; !ok {
				selectedFields = append(selectedFields, tenant.FieldMaxUsers)
				fieldSeen[tenant.FieldMaxUsers] = struct{}{}
			}
		case "features":
			if _, ok := fieldSeen[tenant.FieldFeatures]; !ok {
				selectedFields = append(selectedFields, tenant.FieldFeatures)
				fieldSeen[tenant.FieldFeatures] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		tq.Select(selectedFields...)
	}
	return nil
}

type tenantPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TenantPaginateOption
}

func newTenantPaginateArgs(rv map[string]any) *tenantPaginateArgs {
	args := &tenantPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &TenantOrder{Field: &TenantOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithTenantOrder(order))
			}
		case *TenantOrder:
			if v != nil {
				args.opts = append(args.opts, WithTenantOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*TenantWhereInput); ok {
		args.opts = append(args.opts, WithTenantFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (trq *TenantRoleQuery) CollectFields(ctx context.Context, satisfies ...string) (*TenantRoleQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return trq, nil
	}
	if err := trq.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return trq, nil
}

func (trq *TenantRoleQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(tenantrole.Columns))
		selectedFields = []string{tenantrole.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "permissions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PermissionClient{config: trq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, permissionImplementors)...); err != nil {
				return err
			}
			trq.WithNamedPermissions(alias, func(wq *PermissionQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[tenantrole.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, tenantrole.FieldCreatedAt)
				fieldSeen[tenantrole.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[tenantrole.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, tenantrole.FieldUpdatedAt)
				fieldSeen[tenantrole.FieldUpdatedAt] = struct{}{}
			}
		case "tenantID":
			if _, ok := fieldSeen[tenantrole.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, tenantrole.FieldTenantID)
				fieldSeen[tenantrole.FieldTenantID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[tenantrole.FieldName]; !ok {
				selectedFields = append(selectedFields, tenantrole.FieldName)
				fieldSeen[tenantrole.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[tenantrole.FieldDescription]; !ok {
				selectedFields = append(selectedFields, tenantrole.FieldDescription)
				fieldSeen[tenantrole.FieldDescription] = struct{}{}
			}
		case "sort":
			if _, ok := fieldSeen[tenantrole.FieldSort]; !ok {
				selectedFields = append(selectedFields, tenantrole.FieldSort)
				fieldSeen[tenantrole.FieldSort] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		trq.Select(selectedFields...)
	}
	return nil
}

type tenantrolePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TenantRolePaginateOption
}

func newTenantRolePaginateArgs(rv map[string]any) *tenantrolePaginateArgs {
	args := &tenantrolePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &TenantRoleOrder{Field: &TenantRoleOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithTenantRoleOrder(order))
			}
		case *TenantRoleOrder:
			if v != nil {
				args.opts = append(args.opts, WithTenantRoleOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*TenantRoleWhereInput); ok {
		args.opts = append(args.opts, WithTenantRoleFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (tuq *TenantUserQuery) CollectFields(ctx context.Context, satisfies ...string) (*TenantUserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return tuq, nil
	}
	if err := tuq.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return tuq, nil
}

func (tuq *TenantUserQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(tenantuser.Columns))
		selectedFields = []string{tenantuser.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: tuq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			tuq.withUser = query
			if _, ok := fieldSeen[tenantuser.FieldUserID]; !ok {
				selectedFields = append(selectedFields, tenantuser.FieldUserID)
				fieldSeen[tenantuser.FieldUserID] = struct{}{}
			}

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: tuq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			tuq.withTenant = query
			if _, ok := fieldSeen[tenantuser.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, tenantuser.FieldTenantID)
				fieldSeen[tenantuser.FieldTenantID] = struct{}{}
			}

		case "roles":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantRoleClient{config: tuq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, tenantroleImplementors)...); err != nil {
				return err
			}
			tuq.WithNamedRoles(alias, func(wq *TenantRoleQuery) {
				*wq = *query
			})

		case "memberships":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MembershipClient{config: tuq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, membershipImplementors)...); err != nil {
				return err
			}
			tuq.WithNamedMemberships(alias, func(wq *MembershipQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[tenantuser.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, tenantuser.FieldTenantID)
				fieldSeen[tenantuser.FieldTenantID] = struct{}{}
			}
		case "userID":
			if _, ok := fieldSeen[tenantuser.FieldUserID]; !ok {
				selectedFields = append(selectedFields, tenantuser.FieldUserID)
				fieldSeen[tenantuser.FieldUserID] = struct{}{}
			}
		case "isOwner":
			if _, ok := fieldSeen[tenantuser.FieldIsOwner]; !ok {
				selectedFields = append(selectedFields, tenantuser.FieldIsOwner)
				fieldSeen[tenantuser.FieldIsOwner] = struct{}{}
			}
		case "isActive":
			if _, ok := fieldSeen[tenantuser.FieldIsActive]; !ok {
				selectedFields = append(selectedFields, tenantuser.FieldIsActive)
				fieldSeen[tenantuser.FieldIsActive] = struct{}{}
			}
		case "lastLoginTenant":
			if _, ok := fieldSeen[tenantuser.FieldLastLoginTenant]; !ok {
				selectedFields = append(selectedFields, tenantuser.FieldLastLoginTenant)
				fieldSeen[tenantuser.FieldLastLoginTenant] = struct{}{}
			}
		case "lastLoginAt":
			if _, ok := fieldSeen[tenantuser.FieldLastLoginAt]; !ok {
				selectedFields = append(selectedFields, tenantuser.FieldLastLoginAt)
				fieldSeen[tenantuser.FieldLastLoginAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		tuq.Select(selectedFields...)
	}
	return nil
}

type tenantuserPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TenantUserPaginateOption
}

func newTenantUserPaginateArgs(rv map[string]any) *tenantuserPaginateArgs {
	args := &tenantuserPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*TenantUserWhereInput); ok {
		args.opts = append(args.opts, WithTenantUserFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (uq *UserQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return uq, nil
	}
	if err := uq.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return uq, nil
}

func (uq *UserQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(user.Columns))
		selectedFields = []string{user.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "oauthAccounts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OAuthAccountClient{config: uq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, oauthaccountImplementors)...); err != nil {
				return err
			}
			uq.WithNamedOauthAccounts(alias, func(wq *OAuthAccountQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[user.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldCreatedAt)
				fieldSeen[user.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[user.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldUpdatedAt)
				fieldSeen[user.FieldUpdatedAt] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[user.FieldEmail]; !ok {
				selectedFields = append(selectedFields, user.FieldEmail)
				fieldSeen[user.FieldEmail] = struct{}{}
			}
		case "nickname":
			if _, ok := fieldSeen[user.FieldNickname]; !ok {
				selectedFields = append(selectedFields, user.FieldNickname)
				fieldSeen[user.FieldNickname] = struct{}{}
			}
		case "avatar":
			if _, ok := fieldSeen[user.FieldAvatar]; !ok {
				selectedFields = append(selectedFields, user.FieldAvatar)
				fieldSeen[user.FieldAvatar] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[user.FieldStatus]; !ok {
				selectedFields = append(selectedFields, user.FieldStatus)
				fieldSeen[user.FieldStatus] = struct{}{}
			}
		case "isAdmin":
			if _, ok := fieldSeen[user.FieldIsAdmin]; !ok {
				selectedFields = append(selectedFields, user.FieldIsAdmin)
				fieldSeen[user.FieldIsAdmin] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		uq.Select(selectedFields...)
	}
	return nil
}

type userPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserPaginateOption
}

func newUserPaginateArgs(rv map[string]any) *userPaginateArgs {
	args := &userPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &UserOrder{Field: &UserOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithUserOrder(order))
			}
		case *UserOrder:
			if v != nil {
				args.opts = append(args.opts, WithUserOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*UserWhereInput); ok {
		args.opts = append(args.opts, WithUserFilter(v.Filter))
	}
	return args
}

const (
	afterField     = "after"
	firstField     = "first"
	beforeField    = "before"
	lastField      = "last"
	orderByField   = "orderBy"
	directionField = "direction"
	fieldField     = "field"
	whereField     = "where"
)

func fieldArgs(ctx context.Context, whereInput any, path ...string) map[string]any {
	field := collectedField(ctx, path...)
	if field == nil || field.Arguments == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	args := field.ArgumentMap(oc.Variables)
	return unmarshalArgs(ctx, whereInput, args)
}

// unmarshalArgs allows extracting the field arguments from their raw representation.
func unmarshalArgs(ctx context.Context, whereInput any, args map[string]any) map[string]any {
	for _, k := range []string{firstField, lastField} {
		v, ok := args[k]
		if !ok || v == nil {
			continue
		}
		i, err := graphql.UnmarshalInt(v)
		if err == nil {
			args[k] = &i
		}
	}
	for _, k := range []string{beforeField, afterField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		c := &Cursor{}
		if c.UnmarshalGQL(v) == nil {
			args[k] = c
		}
	}
	if v, ok := args[whereField]; ok && whereInput != nil {
		if err := graphql.UnmarshalInputFromContext(ctx, v, whereInput); err == nil {
			args[whereField] = whereInput
		}
	}

	return args
}

// mayAddCondition appends another type condition to the satisfies list
// if it does not exist in the list.
func mayAddCondition(satisfies []string, typeCond []string) []string {
Cond:
	for _, c := range typeCond {
		for _, s := range satisfies {
			if c == s {
				continue Cond
			}
		}
		satisfies = append(satisfies, c)
	}
	return satisfies
}
