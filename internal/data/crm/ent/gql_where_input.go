// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/go-keg/monorepo/internal/data/crm/ent/contact"
	"github.com/go-keg/monorepo/internal/data/crm/ent/contract"
	"github.com/go-keg/monorepo/internal/data/crm/ent/customer"
	"github.com/go-keg/monorepo/internal/data/crm/ent/followup"
	"github.com/go-keg/monorepo/internal/data/crm/ent/payment"
	"github.com/go-keg/monorepo/internal/data/crm/ent/predicate"
)

// ContactWhereInput represents a where input for filtering Contact queries.
type ContactWhereInput struct {
	Predicates []predicate.Contact  `json:"-"`
	Not        *ContactWhereInput   `json:"not,omitempty"`
	Or         []*ContactWhereInput `json:"or,omitempty"`
	And        []*ContactWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "position" field predicates.
	Position             *string  `json:"position,omitempty"`
	PositionNEQ          *string  `json:"positionNEQ,omitempty"`
	PositionIn           []string `json:"positionIn,omitempty"`
	PositionNotIn        []string `json:"positionNotIn,omitempty"`
	PositionGT           *string  `json:"positionGT,omitempty"`
	PositionGTE          *string  `json:"positionGTE,omitempty"`
	PositionLT           *string  `json:"positionLT,omitempty"`
	PositionLTE          *string  `json:"positionLTE,omitempty"`
	PositionContains     *string  `json:"positionContains,omitempty"`
	PositionHasPrefix    *string  `json:"positionHasPrefix,omitempty"`
	PositionHasSuffix    *string  `json:"positionHasSuffix,omitempty"`
	PositionIsNil        bool     `json:"positionIsNil,omitempty"`
	PositionNotNil       bool     `json:"positionNotNil,omitempty"`
	PositionEqualFold    *string  `json:"positionEqualFold,omitempty"`
	PositionContainsFold *string  `json:"positionContainsFold,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneIsNil        bool     `json:"phoneIsNil,omitempty"`
	PhoneNotNil       bool     `json:"phoneNotNil,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        bool     `json:"emailIsNil,omitempty"`
	EmailNotNil       bool     `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "customer" edge predicates.
	HasCustomer     *bool                 `json:"hasCustomer,omitempty"`
	HasCustomerWith []*CustomerWhereInput `json:"hasCustomerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ContactWhereInput) AddPredicates(predicates ...predicate.Contact) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ContactWhereInput filter on the ContactQuery builder.
func (i *ContactWhereInput) Filter(q *ContactQuery) (*ContactQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyContactWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyContactWhereInput is returned in case the ContactWhereInput is empty.
var ErrEmptyContactWhereInput = errors.New("ent: empty predicate ContactWhereInput")

// P returns a predicate for filtering contacts.
// An error is returned if the input is empty or invalid.
func (i *ContactWhereInput) P() (predicate.Contact, error) {
	var predicates []predicate.Contact
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, contact.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Contact, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, contact.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Contact, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, contact.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, contact.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, contact.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, contact.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, contact.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, contact.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, contact.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, contact.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, contact.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, contact.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, contact.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, contact.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, contact.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, contact.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, contact.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, contact.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, contact.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, contact.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, contact.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, contact.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, contact.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, contact.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, contact.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, contact.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, contact.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, contact.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, contact.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, contact.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, contact.UpdatedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, contact.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, contact.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, contact.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, contact.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, contact.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, contact.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, contact.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, contact.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, contact.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, contact.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, contact.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, contact.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, contact.NameContainsFold(*i.NameContainsFold))
	}
	if i.Position != nil {
		predicates = append(predicates, contact.PositionEQ(*i.Position))
	}
	if i.PositionNEQ != nil {
		predicates = append(predicates, contact.PositionNEQ(*i.PositionNEQ))
	}
	if len(i.PositionIn) > 0 {
		predicates = append(predicates, contact.PositionIn(i.PositionIn...))
	}
	if len(i.PositionNotIn) > 0 {
		predicates = append(predicates, contact.PositionNotIn(i.PositionNotIn...))
	}
	if i.PositionGT != nil {
		predicates = append(predicates, contact.PositionGT(*i.PositionGT))
	}
	if i.PositionGTE != nil {
		predicates = append(predicates, contact.PositionGTE(*i.PositionGTE))
	}
	if i.PositionLT != nil {
		predicates = append(predicates, contact.PositionLT(*i.PositionLT))
	}
	if i.PositionLTE != nil {
		predicates = append(predicates, contact.PositionLTE(*i.PositionLTE))
	}
	if i.PositionContains != nil {
		predicates = append(predicates, contact.PositionContains(*i.PositionContains))
	}
	if i.PositionHasPrefix != nil {
		predicates = append(predicates, contact.PositionHasPrefix(*i.PositionHasPrefix))
	}
	if i.PositionHasSuffix != nil {
		predicates = append(predicates, contact.PositionHasSuffix(*i.PositionHasSuffix))
	}
	if i.PositionIsNil {
		predicates = append(predicates, contact.PositionIsNil())
	}
	if i.PositionNotNil {
		predicates = append(predicates, contact.PositionNotNil())
	}
	if i.PositionEqualFold != nil {
		predicates = append(predicates, contact.PositionEqualFold(*i.PositionEqualFold))
	}
	if i.PositionContainsFold != nil {
		predicates = append(predicates, contact.PositionContainsFold(*i.PositionContainsFold))
	}
	if i.Phone != nil {
		predicates = append(predicates, contact.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, contact.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, contact.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, contact.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, contact.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, contact.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, contact.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, contact.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, contact.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, contact.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, contact.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneIsNil {
		predicates = append(predicates, contact.PhoneIsNil())
	}
	if i.PhoneNotNil {
		predicates = append(predicates, contact.PhoneNotNil())
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, contact.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, contact.PhoneContainsFold(*i.PhoneContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, contact.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, contact.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, contact.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, contact.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, contact.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, contact.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, contact.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, contact.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, contact.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, contact.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, contact.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailIsNil {
		predicates = append(predicates, contact.EmailIsNil())
	}
	if i.EmailNotNil {
		predicates = append(predicates, contact.EmailNotNil())
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, contact.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, contact.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, contact.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, contact.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, contact.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, contact.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, contact.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, contact.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, contact.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, contact.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, contact.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, contact.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, contact.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, contact.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, contact.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, contact.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, contact.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, contact.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, contact.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, contact.UpdatedByNotNil())
	}

	if i.HasCustomer != nil {
		p := contact.HasCustomer()
		if !*i.HasCustomer {
			p = contact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCustomerWith) > 0 {
		with := make([]predicate.Customer, 0, len(i.HasCustomerWith))
		for _, w := range i.HasCustomerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCustomerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, contact.HasCustomerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyContactWhereInput
	case 1:
		return predicates[0], nil
	default:
		return contact.And(predicates...), nil
	}
}

// ContractWhereInput represents a where input for filtering Contract queries.
type ContractWhereInput struct {
	Predicates []predicate.Contract  `json:"-"`
	Not        *ContractWhereInput   `json:"not,omitempty"`
	Or         []*ContractWhereInput `json:"or,omitempty"`
	And        []*ContractWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "contract_no" field predicates.
	ContractNo             *string  `json:"contractNo,omitempty"`
	ContractNoNEQ          *string  `json:"contractNoNEQ,omitempty"`
	ContractNoIn           []string `json:"contractNoIn,omitempty"`
	ContractNoNotIn        []string `json:"contractNoNotIn,omitempty"`
	ContractNoGT           *string  `json:"contractNoGT,omitempty"`
	ContractNoGTE          *string  `json:"contractNoGTE,omitempty"`
	ContractNoLT           *string  `json:"contractNoLT,omitempty"`
	ContractNoLTE          *string  `json:"contractNoLTE,omitempty"`
	ContractNoContains     *string  `json:"contractNoContains,omitempty"`
	ContractNoHasPrefix    *string  `json:"contractNoHasPrefix,omitempty"`
	ContractNoHasSuffix    *string  `json:"contractNoHasSuffix,omitempty"`
	ContractNoEqualFold    *string  `json:"contractNoEqualFold,omitempty"`
	ContractNoContainsFold *string  `json:"contractNoContainsFold,omitempty"`

	// "amount" field predicates.
	Amount      *float64  `json:"amount,omitempty"`
	AmountNEQ   *float64  `json:"amountNEQ,omitempty"`
	AmountIn    []float64 `json:"amountIn,omitempty"`
	AmountNotIn []float64 `json:"amountNotIn,omitempty"`
	AmountGT    *float64  `json:"amountGT,omitempty"`
	AmountGTE   *float64  `json:"amountGTE,omitempty"`
	AmountLT    *float64  `json:"amountLT,omitempty"`
	AmountLTE   *float64  `json:"amountLTE,omitempty"`

	// "signed_at" field predicates.
	SignedAt       *time.Time  `json:"signedAt,omitempty"`
	SignedAtNEQ    *time.Time  `json:"signedAtNEQ,omitempty"`
	SignedAtIn     []time.Time `json:"signedAtIn,omitempty"`
	SignedAtNotIn  []time.Time `json:"signedAtNotIn,omitempty"`
	SignedAtGT     *time.Time  `json:"signedAtGT,omitempty"`
	SignedAtGTE    *time.Time  `json:"signedAtGTE,omitempty"`
	SignedAtLT     *time.Time  `json:"signedAtLT,omitempty"`
	SignedAtLTE    *time.Time  `json:"signedAtLTE,omitempty"`
	SignedAtIsNil  bool        `json:"signedAtIsNil,omitempty"`
	SignedAtNotNil bool        `json:"signedAtNotNil,omitempty"`

	// "end_at" field predicates.
	EndAt       *time.Time  `json:"endAt,omitempty"`
	EndAtNEQ    *time.Time  `json:"endAtNEQ,omitempty"`
	EndAtIn     []time.Time `json:"endAtIn,omitempty"`
	EndAtNotIn  []time.Time `json:"endAtNotIn,omitempty"`
	EndAtGT     *time.Time  `json:"endAtGT,omitempty"`
	EndAtGTE    *time.Time  `json:"endAtGTE,omitempty"`
	EndAtLT     *time.Time  `json:"endAtLT,omitempty"`
	EndAtLTE    *time.Time  `json:"endAtLTE,omitempty"`
	EndAtIsNil  bool        `json:"endAtIsNil,omitempty"`
	EndAtNotNil bool        `json:"endAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "customer" edge predicates.
	HasCustomer     *bool                 `json:"hasCustomer,omitempty"`
	HasCustomerWith []*CustomerWhereInput `json:"hasCustomerWith,omitempty"`

	// "payments" edge predicates.
	HasPayments     *bool                `json:"hasPayments,omitempty"`
	HasPaymentsWith []*PaymentWhereInput `json:"hasPaymentsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ContractWhereInput) AddPredicates(predicates ...predicate.Contract) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ContractWhereInput filter on the ContractQuery builder.
func (i *ContractWhereInput) Filter(q *ContractQuery) (*ContractQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyContractWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyContractWhereInput is returned in case the ContractWhereInput is empty.
var ErrEmptyContractWhereInput = errors.New("ent: empty predicate ContractWhereInput")

// P returns a predicate for filtering contracts.
// An error is returned if the input is empty or invalid.
func (i *ContractWhereInput) P() (predicate.Contract, error) {
	var predicates []predicate.Contract
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, contract.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Contract, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, contract.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Contract, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, contract.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, contract.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, contract.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, contract.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, contract.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, contract.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, contract.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, contract.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, contract.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, contract.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, contract.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, contract.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, contract.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, contract.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, contract.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, contract.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, contract.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, contract.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, contract.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, contract.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, contract.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, contract.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, contract.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, contract.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, contract.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, contract.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, contract.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, contract.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, contract.UpdatedAtNotNil())
	}
	if i.ContractNo != nil {
		predicates = append(predicates, contract.ContractNoEQ(*i.ContractNo))
	}
	if i.ContractNoNEQ != nil {
		predicates = append(predicates, contract.ContractNoNEQ(*i.ContractNoNEQ))
	}
	if len(i.ContractNoIn) > 0 {
		predicates = append(predicates, contract.ContractNoIn(i.ContractNoIn...))
	}
	if len(i.ContractNoNotIn) > 0 {
		predicates = append(predicates, contract.ContractNoNotIn(i.ContractNoNotIn...))
	}
	if i.ContractNoGT != nil {
		predicates = append(predicates, contract.ContractNoGT(*i.ContractNoGT))
	}
	if i.ContractNoGTE != nil {
		predicates = append(predicates, contract.ContractNoGTE(*i.ContractNoGTE))
	}
	if i.ContractNoLT != nil {
		predicates = append(predicates, contract.ContractNoLT(*i.ContractNoLT))
	}
	if i.ContractNoLTE != nil {
		predicates = append(predicates, contract.ContractNoLTE(*i.ContractNoLTE))
	}
	if i.ContractNoContains != nil {
		predicates = append(predicates, contract.ContractNoContains(*i.ContractNoContains))
	}
	if i.ContractNoHasPrefix != nil {
		predicates = append(predicates, contract.ContractNoHasPrefix(*i.ContractNoHasPrefix))
	}
	if i.ContractNoHasSuffix != nil {
		predicates = append(predicates, contract.ContractNoHasSuffix(*i.ContractNoHasSuffix))
	}
	if i.ContractNoEqualFold != nil {
		predicates = append(predicates, contract.ContractNoEqualFold(*i.ContractNoEqualFold))
	}
	if i.ContractNoContainsFold != nil {
		predicates = append(predicates, contract.ContractNoContainsFold(*i.ContractNoContainsFold))
	}
	if i.Amount != nil {
		predicates = append(predicates, contract.AmountEQ(*i.Amount))
	}
	if i.AmountNEQ != nil {
		predicates = append(predicates, contract.AmountNEQ(*i.AmountNEQ))
	}
	if len(i.AmountIn) > 0 {
		predicates = append(predicates, contract.AmountIn(i.AmountIn...))
	}
	if len(i.AmountNotIn) > 0 {
		predicates = append(predicates, contract.AmountNotIn(i.AmountNotIn...))
	}
	if i.AmountGT != nil {
		predicates = append(predicates, contract.AmountGT(*i.AmountGT))
	}
	if i.AmountGTE != nil {
		predicates = append(predicates, contract.AmountGTE(*i.AmountGTE))
	}
	if i.AmountLT != nil {
		predicates = append(predicates, contract.AmountLT(*i.AmountLT))
	}
	if i.AmountLTE != nil {
		predicates = append(predicates, contract.AmountLTE(*i.AmountLTE))
	}
	if i.SignedAt != nil {
		predicates = append(predicates, contract.SignedAtEQ(*i.SignedAt))
	}
	if i.SignedAtNEQ != nil {
		predicates = append(predicates, contract.SignedAtNEQ(*i.SignedAtNEQ))
	}
	if len(i.SignedAtIn) > 0 {
		predicates = append(predicates, contract.SignedAtIn(i.SignedAtIn...))
	}
	if len(i.SignedAtNotIn) > 0 {
		predicates = append(predicates, contract.SignedAtNotIn(i.SignedAtNotIn...))
	}
	if i.SignedAtGT != nil {
		predicates = append(predicates, contract.SignedAtGT(*i.SignedAtGT))
	}
	if i.SignedAtGTE != nil {
		predicates = append(predicates, contract.SignedAtGTE(*i.SignedAtGTE))
	}
	if i.SignedAtLT != nil {
		predicates = append(predicates, contract.SignedAtLT(*i.SignedAtLT))
	}
	if i.SignedAtLTE != nil {
		predicates = append(predicates, contract.SignedAtLTE(*i.SignedAtLTE))
	}
	if i.SignedAtIsNil {
		predicates = append(predicates, contract.SignedAtIsNil())
	}
	if i.SignedAtNotNil {
		predicates = append(predicates, contract.SignedAtNotNil())
	}
	if i.EndAt != nil {
		predicates = append(predicates, contract.EndAtEQ(*i.EndAt))
	}
	if i.EndAtNEQ != nil {
		predicates = append(predicates, contract.EndAtNEQ(*i.EndAtNEQ))
	}
	if len(i.EndAtIn) > 0 {
		predicates = append(predicates, contract.EndAtIn(i.EndAtIn...))
	}
	if len(i.EndAtNotIn) > 0 {
		predicates = append(predicates, contract.EndAtNotIn(i.EndAtNotIn...))
	}
	if i.EndAtGT != nil {
		predicates = append(predicates, contract.EndAtGT(*i.EndAtGT))
	}
	if i.EndAtGTE != nil {
		predicates = append(predicates, contract.EndAtGTE(*i.EndAtGTE))
	}
	if i.EndAtLT != nil {
		predicates = append(predicates, contract.EndAtLT(*i.EndAtLT))
	}
	if i.EndAtLTE != nil {
		predicates = append(predicates, contract.EndAtLTE(*i.EndAtLTE))
	}
	if i.EndAtIsNil {
		predicates = append(predicates, contract.EndAtIsNil())
	}
	if i.EndAtNotNil {
		predicates = append(predicates, contract.EndAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, contract.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, contract.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, contract.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, contract.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, contract.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, contract.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, contract.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, contract.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, contract.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, contract.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, contract.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, contract.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, contract.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, contract.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, contract.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, contract.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, contract.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, contract.UpdatedByNotNil())
	}

	if i.HasCustomer != nil {
		p := contract.HasCustomer()
		if !*i.HasCustomer {
			p = contract.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCustomerWith) > 0 {
		with := make([]predicate.Customer, 0, len(i.HasCustomerWith))
		for _, w := range i.HasCustomerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCustomerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, contract.HasCustomerWith(with...))
	}
	if i.HasPayments != nil {
		p := contract.HasPayments()
		if !*i.HasPayments {
			p = contract.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPaymentsWith) > 0 {
		with := make([]predicate.Payment, 0, len(i.HasPaymentsWith))
		for _, w := range i.HasPaymentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPaymentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, contract.HasPaymentsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyContractWhereInput
	case 1:
		return predicates[0], nil
	default:
		return contract.And(predicates...), nil
	}
}

// CustomerWhereInput represents a where input for filtering Customer queries.
type CustomerWhereInput struct {
	Predicates []predicate.Customer  `json:"-"`
	Not        *CustomerWhereInput   `json:"not,omitempty"`
	Or         []*CustomerWhereInput `json:"or,omitempty"`
	And        []*CustomerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "industry" field predicates.
	Industry             *string  `json:"industry,omitempty"`
	IndustryNEQ          *string  `json:"industryNEQ,omitempty"`
	IndustryIn           []string `json:"industryIn,omitempty"`
	IndustryNotIn        []string `json:"industryNotIn,omitempty"`
	IndustryGT           *string  `json:"industryGT,omitempty"`
	IndustryGTE          *string  `json:"industryGTE,omitempty"`
	IndustryLT           *string  `json:"industryLT,omitempty"`
	IndustryLTE          *string  `json:"industryLTE,omitempty"`
	IndustryContains     *string  `json:"industryContains,omitempty"`
	IndustryHasPrefix    *string  `json:"industryHasPrefix,omitempty"`
	IndustryHasSuffix    *string  `json:"industryHasSuffix,omitempty"`
	IndustryIsNil        bool     `json:"industryIsNil,omitempty"`
	IndustryNotNil       bool     `json:"industryNotNil,omitempty"`
	IndustryEqualFold    *string  `json:"industryEqualFold,omitempty"`
	IndustryContainsFold *string  `json:"industryContainsFold,omitempty"`

	// "source" field predicates.
	Source             *string  `json:"source,omitempty"`
	SourceNEQ          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGT           *string  `json:"sourceGT,omitempty"`
	SourceGTE          *string  `json:"sourceGTE,omitempty"`
	SourceLT           *string  `json:"sourceLT,omitempty"`
	SourceLTE          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        bool     `json:"sourceIsNil,omitempty"`
	SourceNotNil       bool     `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`

	// "level" field predicates.
	Level             *string  `json:"level,omitempty"`
	LevelNEQ          *string  `json:"levelNEQ,omitempty"`
	LevelIn           []string `json:"levelIn,omitempty"`
	LevelNotIn        []string `json:"levelNotIn,omitempty"`
	LevelGT           *string  `json:"levelGT,omitempty"`
	LevelGTE          *string  `json:"levelGTE,omitempty"`
	LevelLT           *string  `json:"levelLT,omitempty"`
	LevelLTE          *string  `json:"levelLTE,omitempty"`
	LevelContains     *string  `json:"levelContains,omitempty"`
	LevelHasPrefix    *string  `json:"levelHasPrefix,omitempty"`
	LevelHasSuffix    *string  `json:"levelHasSuffix,omitempty"`
	LevelIsNil        bool     `json:"levelIsNil,omitempty"`
	LevelNotNil       bool     `json:"levelNotNil,omitempty"`
	LevelEqualFold    *string  `json:"levelEqualFold,omitempty"`
	LevelContainsFold *string  `json:"levelContainsFold,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "contacts" edge predicates.
	HasContacts     *bool                `json:"hasContacts,omitempty"`
	HasContactsWith []*ContactWhereInput `json:"hasContactsWith,omitempty"`

	// "contracts" edge predicates.
	HasContracts     *bool                 `json:"hasContracts,omitempty"`
	HasContractsWith []*ContractWhereInput `json:"hasContractsWith,omitempty"`

	// "follow_ups" edge predicates.
	HasFollowUps     *bool                 `json:"hasFollowUps,omitempty"`
	HasFollowUpsWith []*FollowUpWhereInput `json:"hasFollowUpsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CustomerWhereInput) AddPredicates(predicates ...predicate.Customer) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CustomerWhereInput filter on the CustomerQuery builder.
func (i *CustomerWhereInput) Filter(q *CustomerQuery) (*CustomerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCustomerWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCustomerWhereInput is returned in case the CustomerWhereInput is empty.
var ErrEmptyCustomerWhereInput = errors.New("ent: empty predicate CustomerWhereInput")

// P returns a predicate for filtering customers.
// An error is returned if the input is empty or invalid.
func (i *CustomerWhereInput) P() (predicate.Customer, error) {
	var predicates []predicate.Customer
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, customer.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Customer, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, customer.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Customer, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, customer.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, customer.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, customer.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, customer.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, customer.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, customer.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, customer.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, customer.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, customer.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, customer.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, customer.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, customer.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, customer.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, customer.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, customer.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, customer.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, customer.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, customer.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, customer.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, customer.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, customer.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, customer.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, customer.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, customer.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, customer.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, customer.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, customer.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, customer.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, customer.UpdatedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, customer.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, customer.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, customer.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, customer.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, customer.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, customer.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, customer.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, customer.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, customer.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, customer.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, customer.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, customer.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, customer.NameContainsFold(*i.NameContainsFold))
	}
	if i.Industry != nil {
		predicates = append(predicates, customer.IndustryEQ(*i.Industry))
	}
	if i.IndustryNEQ != nil {
		predicates = append(predicates, customer.IndustryNEQ(*i.IndustryNEQ))
	}
	if len(i.IndustryIn) > 0 {
		predicates = append(predicates, customer.IndustryIn(i.IndustryIn...))
	}
	if len(i.IndustryNotIn) > 0 {
		predicates = append(predicates, customer.IndustryNotIn(i.IndustryNotIn...))
	}
	if i.IndustryGT != nil {
		predicates = append(predicates, customer.IndustryGT(*i.IndustryGT))
	}
	if i.IndustryGTE != nil {
		predicates = append(predicates, customer.IndustryGTE(*i.IndustryGTE))
	}
	if i.IndustryLT != nil {
		predicates = append(predicates, customer.IndustryLT(*i.IndustryLT))
	}
	if i.IndustryLTE != nil {
		predicates = append(predicates, customer.IndustryLTE(*i.IndustryLTE))
	}
	if i.IndustryContains != nil {
		predicates = append(predicates, customer.IndustryContains(*i.IndustryContains))
	}
	if i.IndustryHasPrefix != nil {
		predicates = append(predicates, customer.IndustryHasPrefix(*i.IndustryHasPrefix))
	}
	if i.IndustryHasSuffix != nil {
		predicates = append(predicates, customer.IndustryHasSuffix(*i.IndustryHasSuffix))
	}
	if i.IndustryIsNil {
		predicates = append(predicates, customer.IndustryIsNil())
	}
	if i.IndustryNotNil {
		predicates = append(predicates, customer.IndustryNotNil())
	}
	if i.IndustryEqualFold != nil {
		predicates = append(predicates, customer.IndustryEqualFold(*i.IndustryEqualFold))
	}
	if i.IndustryContainsFold != nil {
		predicates = append(predicates, customer.IndustryContainsFold(*i.IndustryContainsFold))
	}
	if i.Source != nil {
		predicates = append(predicates, customer.SourceEQ(*i.Source))
	}
	if i.SourceNEQ != nil {
		predicates = append(predicates, customer.SourceNEQ(*i.SourceNEQ))
	}
	if len(i.SourceIn) > 0 {
		predicates = append(predicates, customer.SourceIn(i.SourceIn...))
	}
	if len(i.SourceNotIn) > 0 {
		predicates = append(predicates, customer.SourceNotIn(i.SourceNotIn...))
	}
	if i.SourceGT != nil {
		predicates = append(predicates, customer.SourceGT(*i.SourceGT))
	}
	if i.SourceGTE != nil {
		predicates = append(predicates, customer.SourceGTE(*i.SourceGTE))
	}
	if i.SourceLT != nil {
		predicates = append(predicates, customer.SourceLT(*i.SourceLT))
	}
	if i.SourceLTE != nil {
		predicates = append(predicates, customer.SourceLTE(*i.SourceLTE))
	}
	if i.SourceContains != nil {
		predicates = append(predicates, customer.SourceContains(*i.SourceContains))
	}
	if i.SourceHasPrefix != nil {
		predicates = append(predicates, customer.SourceHasPrefix(*i.SourceHasPrefix))
	}
	if i.SourceHasSuffix != nil {
		predicates = append(predicates, customer.SourceHasSuffix(*i.SourceHasSuffix))
	}
	if i.SourceIsNil {
		predicates = append(predicates, customer.SourceIsNil())
	}
	if i.SourceNotNil {
		predicates = append(predicates, customer.SourceNotNil())
	}
	if i.SourceEqualFold != nil {
		predicates = append(predicates, customer.SourceEqualFold(*i.SourceEqualFold))
	}
	if i.SourceContainsFold != nil {
		predicates = append(predicates, customer.SourceContainsFold(*i.SourceContainsFold))
	}
	if i.Level != nil {
		predicates = append(predicates, customer.LevelEQ(*i.Level))
	}
	if i.LevelNEQ != nil {
		predicates = append(predicates, customer.LevelNEQ(*i.LevelNEQ))
	}
	if len(i.LevelIn) > 0 {
		predicates = append(predicates, customer.LevelIn(i.LevelIn...))
	}
	if len(i.LevelNotIn) > 0 {
		predicates = append(predicates, customer.LevelNotIn(i.LevelNotIn...))
	}
	if i.LevelGT != nil {
		predicates = append(predicates, customer.LevelGT(*i.LevelGT))
	}
	if i.LevelGTE != nil {
		predicates = append(predicates, customer.LevelGTE(*i.LevelGTE))
	}
	if i.LevelLT != nil {
		predicates = append(predicates, customer.LevelLT(*i.LevelLT))
	}
	if i.LevelLTE != nil {
		predicates = append(predicates, customer.LevelLTE(*i.LevelLTE))
	}
	if i.LevelContains != nil {
		predicates = append(predicates, customer.LevelContains(*i.LevelContains))
	}
	if i.LevelHasPrefix != nil {
		predicates = append(predicates, customer.LevelHasPrefix(*i.LevelHasPrefix))
	}
	if i.LevelHasSuffix != nil {
		predicates = append(predicates, customer.LevelHasSuffix(*i.LevelHasSuffix))
	}
	if i.LevelIsNil {
		predicates = append(predicates, customer.LevelIsNil())
	}
	if i.LevelNotNil {
		predicates = append(predicates, customer.LevelNotNil())
	}
	if i.LevelEqualFold != nil {
		predicates = append(predicates, customer.LevelEqualFold(*i.LevelEqualFold))
	}
	if i.LevelContainsFold != nil {
		predicates = append(predicates, customer.LevelContainsFold(*i.LevelContainsFold))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, customer.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, customer.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, customer.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, customer.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, customer.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, customer.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, customer.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, customer.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, customer.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, customer.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, customer.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, customer.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, customer.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, customer.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, customer.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, customer.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, customer.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, customer.UpdatedByNotNil())
	}

	if i.HasContacts != nil {
		p := customer.HasContacts()
		if !*i.HasContacts {
			p = customer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasContactsWith) > 0 {
		with := make([]predicate.Contact, 0, len(i.HasContactsWith))
		for _, w := range i.HasContactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasContactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, customer.HasContactsWith(with...))
	}
	if i.HasContracts != nil {
		p := customer.HasContracts()
		if !*i.HasContracts {
			p = customer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasContractsWith) > 0 {
		with := make([]predicate.Contract, 0, len(i.HasContractsWith))
		for _, w := range i.HasContractsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasContractsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, customer.HasContractsWith(with...))
	}
	if i.HasFollowUps != nil {
		p := customer.HasFollowUps()
		if !*i.HasFollowUps {
			p = customer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFollowUpsWith) > 0 {
		with := make([]predicate.FollowUp, 0, len(i.HasFollowUpsWith))
		for _, w := range i.HasFollowUpsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFollowUpsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, customer.HasFollowUpsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCustomerWhereInput
	case 1:
		return predicates[0], nil
	default:
		return customer.And(predicates...), nil
	}
}

// FollowUpWhereInput represents a where input for filtering FollowUp queries.
type FollowUpWhereInput struct {
	Predicates []predicate.FollowUp  `json:"-"`
	Not        *FollowUpWhereInput   `json:"not,omitempty"`
	Or         []*FollowUpWhereInput `json:"or,omitempty"`
	And        []*FollowUpWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "type" field predicates.
	Type      *followup.Type  `json:"type,omitempty"`
	TypeNEQ   *followup.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []followup.Type `json:"typeIn,omitempty"`
	TypeNotIn []followup.Type `json:"typeNotIn,omitempty"`

	// "content" field predicates.
	Content             *string  `json:"content,omitempty"`
	ContentNEQ          *string  `json:"contentNEQ,omitempty"`
	ContentIn           []string `json:"contentIn,omitempty"`
	ContentNotIn        []string `json:"contentNotIn,omitempty"`
	ContentGT           *string  `json:"contentGT,omitempty"`
	ContentGTE          *string  `json:"contentGTE,omitempty"`
	ContentLT           *string  `json:"contentLT,omitempty"`
	ContentLTE          *string  `json:"contentLTE,omitempty"`
	ContentContains     *string  `json:"contentContains,omitempty"`
	ContentHasPrefix    *string  `json:"contentHasPrefix,omitempty"`
	ContentHasSuffix    *string  `json:"contentHasSuffix,omitempty"`
	ContentEqualFold    *string  `json:"contentEqualFold,omitempty"`
	ContentContainsFold *string  `json:"contentContainsFold,omitempty"`

	// "followed_at" field predicates.
	FollowedAt      *time.Time  `json:"followedAt,omitempty"`
	FollowedAtNEQ   *time.Time  `json:"followedAtNEQ,omitempty"`
	FollowedAtIn    []time.Time `json:"followedAtIn,omitempty"`
	FollowedAtNotIn []time.Time `json:"followedAtNotIn,omitempty"`
	FollowedAtGT    *time.Time  `json:"followedAtGT,omitempty"`
	FollowedAtGTE   *time.Time  `json:"followedAtGTE,omitempty"`
	FollowedAtLT    *time.Time  `json:"followedAtLT,omitempty"`
	FollowedAtLTE   *time.Time  `json:"followedAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "customer" edge predicates.
	HasCustomer     *bool                 `json:"hasCustomer,omitempty"`
	HasCustomerWith []*CustomerWhereInput `json:"hasCustomerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *FollowUpWhereInput) AddPredicates(predicates ...predicate.FollowUp) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the FollowUpWhereInput filter on the FollowUpQuery builder.
func (i *FollowUpWhereInput) Filter(q *FollowUpQuery) (*FollowUpQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyFollowUpWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyFollowUpWhereInput is returned in case the FollowUpWhereInput is empty.
var ErrEmptyFollowUpWhereInput = errors.New("ent: empty predicate FollowUpWhereInput")

// P returns a predicate for filtering followups.
// An error is returned if the input is empty or invalid.
func (i *FollowUpWhereInput) P() (predicate.FollowUp, error) {
	var predicates []predicate.FollowUp
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, followup.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.FollowUp, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, followup.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.FollowUp, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, followup.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, followup.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, followup.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, followup.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, followup.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, followup.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, followup.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, followup.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, followup.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, followup.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, followup.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, followup.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, followup.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, followup.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, followup.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, followup.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, followup.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, followup.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, followup.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, followup.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, followup.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, followup.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, followup.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, followup.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, followup.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, followup.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, followup.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, followup.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, followup.UpdatedAtNotNil())
	}
	if i.Type != nil {
		predicates = append(predicates, followup.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, followup.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, followup.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, followup.TypeNotIn(i.TypeNotIn...))
	}
	if i.Content != nil {
		predicates = append(predicates, followup.ContentEQ(*i.Content))
	}
	if i.ContentNEQ != nil {
		predicates = append(predicates, followup.ContentNEQ(*i.ContentNEQ))
	}
	if len(i.ContentIn) > 0 {
		predicates = append(predicates, followup.ContentIn(i.ContentIn...))
	}
	if len(i.ContentNotIn) > 0 {
		predicates = append(predicates, followup.ContentNotIn(i.ContentNotIn...))
	}
	if i.ContentGT != nil {
		predicates = append(predicates, followup.ContentGT(*i.ContentGT))
	}
	if i.ContentGTE != nil {
		predicates = append(predicates, followup.ContentGTE(*i.ContentGTE))
	}
	if i.ContentLT != nil {
		predicates = append(predicates, followup.ContentLT(*i.ContentLT))
	}
	if i.ContentLTE != nil {
		predicates = append(predicates, followup.ContentLTE(*i.ContentLTE))
	}
	if i.ContentContains != nil {
		predicates = append(predicates, followup.ContentContains(*i.ContentContains))
	}
	if i.ContentHasPrefix != nil {
		predicates = append(predicates, followup.ContentHasPrefix(*i.ContentHasPrefix))
	}
	if i.ContentHasSuffix != nil {
		predicates = append(predicates, followup.ContentHasSuffix(*i.ContentHasSuffix))
	}
	if i.ContentEqualFold != nil {
		predicates = append(predicates, followup.ContentEqualFold(*i.ContentEqualFold))
	}
	if i.ContentContainsFold != nil {
		predicates = append(predicates, followup.ContentContainsFold(*i.ContentContainsFold))
	}
	if i.FollowedAt != nil {
		predicates = append(predicates, followup.FollowedAtEQ(*i.FollowedAt))
	}
	if i.FollowedAtNEQ != nil {
		predicates = append(predicates, followup.FollowedAtNEQ(*i.FollowedAtNEQ))
	}
	if len(i.FollowedAtIn) > 0 {
		predicates = append(predicates, followup.FollowedAtIn(i.FollowedAtIn...))
	}
	if len(i.FollowedAtNotIn) > 0 {
		predicates = append(predicates, followup.FollowedAtNotIn(i.FollowedAtNotIn...))
	}
	if i.FollowedAtGT != nil {
		predicates = append(predicates, followup.FollowedAtGT(*i.FollowedAtGT))
	}
	if i.FollowedAtGTE != nil {
		predicates = append(predicates, followup.FollowedAtGTE(*i.FollowedAtGTE))
	}
	if i.FollowedAtLT != nil {
		predicates = append(predicates, followup.FollowedAtLT(*i.FollowedAtLT))
	}
	if i.FollowedAtLTE != nil {
		predicates = append(predicates, followup.FollowedAtLTE(*i.FollowedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, followup.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, followup.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, followup.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, followup.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, followup.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, followup.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, followup.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, followup.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, followup.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, followup.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, followup.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, followup.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, followup.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, followup.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, followup.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, followup.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, followup.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, followup.UpdatedByNotNil())
	}

	if i.HasCustomer != nil {
		p := followup.HasCustomer()
		if !*i.HasCustomer {
			p = followup.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCustomerWith) > 0 {
		with := make([]predicate.Customer, 0, len(i.HasCustomerWith))
		for _, w := range i.HasCustomerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCustomerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, followup.HasCustomerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyFollowUpWhereInput
	case 1:
		return predicates[0], nil
	default:
		return followup.And(predicates...), nil
	}
}

// PaymentWhereInput represents a where input for filtering Payment queries.
type PaymentWhereInput struct {
	Predicates []predicate.Payment  `json:"-"`
	Not        *PaymentWhereInput   `json:"not,omitempty"`
	Or         []*PaymentWhereInput `json:"or,omitempty"`
	And        []*PaymentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "amount" field predicates.
	Amount      *float64  `json:"amount,omitempty"`
	AmountNEQ   *float64  `json:"amountNEQ,omitempty"`
	AmountIn    []float64 `json:"amountIn,omitempty"`
	AmountNotIn []float64 `json:"amountNotIn,omitempty"`
	AmountGT    *float64  `json:"amountGT,omitempty"`
	AmountGTE   *float64  `json:"amountGTE,omitempty"`
	AmountLT    *float64  `json:"amountLT,omitempty"`
	AmountLTE   *float64  `json:"amountLTE,omitempty"`

	// "received_at" field predicates.
	ReceivedAt       *time.Time  `json:"receivedAt,omitempty"`
	ReceivedAtNEQ    *time.Time  `json:"receivedAtNEQ,omitempty"`
	ReceivedAtIn     []time.Time `json:"receivedAtIn,omitempty"`
	ReceivedAtNotIn  []time.Time `json:"receivedAtNotIn,omitempty"`
	ReceivedAtGT     *time.Time  `json:"receivedAtGT,omitempty"`
	ReceivedAtGTE    *time.Time  `json:"receivedAtGTE,omitempty"`
	ReceivedAtLT     *time.Time  `json:"receivedAtLT,omitempty"`
	ReceivedAtLTE    *time.Time  `json:"receivedAtLTE,omitempty"`
	ReceivedAtIsNil  bool        `json:"receivedAtIsNil,omitempty"`
	ReceivedAtNotNil bool        `json:"receivedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "contract" edge predicates.
	HasContract     *bool                 `json:"hasContract,omitempty"`
	HasContractWith []*ContractWhereInput `json:"hasContractWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PaymentWhereInput) AddPredicates(predicates ...predicate.Payment) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PaymentWhereInput filter on the PaymentQuery builder.
func (i *PaymentWhereInput) Filter(q *PaymentQuery) (*PaymentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPaymentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPaymentWhereInput is returned in case the PaymentWhereInput is empty.
var ErrEmptyPaymentWhereInput = errors.New("ent: empty predicate PaymentWhereInput")

// P returns a predicate for filtering payments.
// An error is returned if the input is empty or invalid.
func (i *PaymentWhereInput) P() (predicate.Payment, error) {
	var predicates []predicate.Payment
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, payment.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Payment, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, payment.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Payment, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, payment.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, payment.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, payment.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, payment.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, payment.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, payment.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, payment.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, payment.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, payment.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, payment.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, payment.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, payment.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, payment.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, payment.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, payment.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, payment.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, payment.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, payment.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, payment.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, payment.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, payment.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, payment.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, payment.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, payment.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, payment.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, payment.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, payment.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, payment.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, payment.UpdatedAtNotNil())
	}
	if i.Amount != nil {
		predicates = append(predicates, payment.AmountEQ(*i.Amount))
	}
	if i.AmountNEQ != nil {
		predicates = append(predicates, payment.AmountNEQ(*i.AmountNEQ))
	}
	if len(i.AmountIn) > 0 {
		predicates = append(predicates, payment.AmountIn(i.AmountIn...))
	}
	if len(i.AmountNotIn) > 0 {
		predicates = append(predicates, payment.AmountNotIn(i.AmountNotIn...))
	}
	if i.AmountGT != nil {
		predicates = append(predicates, payment.AmountGT(*i.AmountGT))
	}
	if i.AmountGTE != nil {
		predicates = append(predicates, payment.AmountGTE(*i.AmountGTE))
	}
	if i.AmountLT != nil {
		predicates = append(predicates, payment.AmountLT(*i.AmountLT))
	}
	if i.AmountLTE != nil {
		predicates = append(predicates, payment.AmountLTE(*i.AmountLTE))
	}
	if i.ReceivedAt != nil {
		predicates = append(predicates, payment.ReceivedAtEQ(*i.ReceivedAt))
	}
	if i.ReceivedAtNEQ != nil {
		predicates = append(predicates, payment.ReceivedAtNEQ(*i.ReceivedAtNEQ))
	}
	if len(i.ReceivedAtIn) > 0 {
		predicates = append(predicates, payment.ReceivedAtIn(i.ReceivedAtIn...))
	}
	if len(i.ReceivedAtNotIn) > 0 {
		predicates = append(predicates, payment.ReceivedAtNotIn(i.ReceivedAtNotIn...))
	}
	if i.ReceivedAtGT != nil {
		predicates = append(predicates, payment.ReceivedAtGT(*i.ReceivedAtGT))
	}
	if i.ReceivedAtGTE != nil {
		predicates = append(predicates, payment.ReceivedAtGTE(*i.ReceivedAtGTE))
	}
	if i.ReceivedAtLT != nil {
		predicates = append(predicates, payment.ReceivedAtLT(*i.ReceivedAtLT))
	}
	if i.ReceivedAtLTE != nil {
		predicates = append(predicates, payment.ReceivedAtLTE(*i.ReceivedAtLTE))
	}
	if i.ReceivedAtIsNil {
		predicates = append(predicates, payment.ReceivedAtIsNil())
	}
	if i.ReceivedAtNotNil {
		predicates = append(predicates, payment.ReceivedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, payment.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, payment.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, payment.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, payment.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, payment.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, payment.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, payment.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, payment.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, payment.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, payment.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, payment.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, payment.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, payment.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, payment.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, payment.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, payment.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, payment.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, payment.UpdatedByNotNil())
	}

	if i.HasContract != nil {
		p := payment.HasContract()
		if !*i.HasContract {
			p = payment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasContractWith) > 0 {
		with := make([]predicate.Contract, 0, len(i.HasContractWith))
		for _, w := range i.HasContractWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasContractWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, payment.HasContractWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPaymentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return payment.And(predicates...), nil
	}
}
