// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"github.com/99designs/gqlgen/graphql"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *ContactQuery) CustomCollectFields(ctx context.Context, path ...string) (*ContactQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if field := collectedField(ctx, path...); field != nil {
		if err := c.collectField(ctx, true, graphql.GetOperationContext(ctx), *field, path); err != nil {
			return nil, err
		}
	}
	return c, nil
}

// AllCollectFields
func (c *ContactQuery) AllCollectFields(ctx context.Context, path ...string) ([]*Contact, error) {
	_query, err := c.CustomCollectFields(ctx, path...)
	if err != nil {
		return nil, err
	}
	return _query.All(ctx)
}

// FirstCollectFields
func (c *ContactQuery) FirstCollectFields(ctx context.Context, path ...string) (*Contact, error) {
	_query, err := c.CustomCollectFields(ctx, path...)
	if err != nil {
		return nil, err
	}
	return _query.First(ctx)
}

// List executes the query and returns totalCount and nodes []*Contact.
func (c *ContactQuery) List(ctx context.Context, offset, limit int, opts ...ContactPaginateOption) (*ContactConnection, error) {
	pager, err := newContactPager(opts, false)
	if err != nil {
		return nil, err
	}
	if _, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &ContactConnection{}
	ignoredNodes := !hasCollectedField(ctx, edgesField, nodeField) && !hasCollectedField(ctx, nodesField)
	if hasCollectedField(ctx, totalCountField) {
		hasPagination := limit != 0
		if hasPagination || ignoredNodes {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
		}
	}
	if ignoredNodes || (limit == 0) {
		return conn, nil
	}
	c.Offset(offset).Limit(limit)
	if field := collectedField(ctx, nodesField); field != nil {
		if err = c.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{nodesField}); err != nil {
			return nil, err
		}
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	conn.Nodes, err = pager.applyOrder(c).All(ctx)
	if err != nil {
		return nil, err
	}
	return conn, nil
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *ContractQuery) CustomCollectFields(ctx context.Context, path ...string) (*ContractQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if field := collectedField(ctx, path...); field != nil {
		if err := c.collectField(ctx, true, graphql.GetOperationContext(ctx), *field, path); err != nil {
			return nil, err
		}
	}
	return c, nil
}

// AllCollectFields
func (c *ContractQuery) AllCollectFields(ctx context.Context, path ...string) ([]*Contract, error) {
	_query, err := c.CustomCollectFields(ctx, path...)
	if err != nil {
		return nil, err
	}
	return _query.All(ctx)
}

// FirstCollectFields
func (c *ContractQuery) FirstCollectFields(ctx context.Context, path ...string) (*Contract, error) {
	_query, err := c.CustomCollectFields(ctx, path...)
	if err != nil {
		return nil, err
	}
	return _query.First(ctx)
}

// List executes the query and returns totalCount and nodes []*Contract.
func (c *ContractQuery) List(ctx context.Context, offset, limit int, opts ...ContractPaginateOption) (*ContractConnection, error) {
	pager, err := newContractPager(opts, false)
	if err != nil {
		return nil, err
	}
	if _, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &ContractConnection{}
	ignoredNodes := !hasCollectedField(ctx, edgesField, nodeField) && !hasCollectedField(ctx, nodesField)
	if hasCollectedField(ctx, totalCountField) {
		hasPagination := limit != 0
		if hasPagination || ignoredNodes {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
		}
	}
	if ignoredNodes || (limit == 0) {
		return conn, nil
	}
	c.Offset(offset).Limit(limit)
	if field := collectedField(ctx, nodesField); field != nil {
		if err = c.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{nodesField}); err != nil {
			return nil, err
		}
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	conn.Nodes, err = pager.applyOrder(c).All(ctx)
	if err != nil {
		return nil, err
	}
	return conn, nil
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *CustomerQuery) CustomCollectFields(ctx context.Context, path ...string) (*CustomerQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if field := collectedField(ctx, path...); field != nil {
		if err := c.collectField(ctx, true, graphql.GetOperationContext(ctx), *field, path); err != nil {
			return nil, err
		}
	}
	return c, nil
}

// AllCollectFields
func (c *CustomerQuery) AllCollectFields(ctx context.Context, path ...string) ([]*Customer, error) {
	_query, err := c.CustomCollectFields(ctx, path...)
	if err != nil {
		return nil, err
	}
	return _query.All(ctx)
}

// FirstCollectFields
func (c *CustomerQuery) FirstCollectFields(ctx context.Context, path ...string) (*Customer, error) {
	_query, err := c.CustomCollectFields(ctx, path...)
	if err != nil {
		return nil, err
	}
	return _query.First(ctx)
}

// List executes the query and returns totalCount and nodes []*Customer.
func (c *CustomerQuery) List(ctx context.Context, offset, limit int, opts ...CustomerPaginateOption) (*CustomerConnection, error) {
	pager, err := newCustomerPager(opts, false)
	if err != nil {
		return nil, err
	}
	if _, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CustomerConnection{}
	ignoredNodes := !hasCollectedField(ctx, edgesField, nodeField) && !hasCollectedField(ctx, nodesField)
	if hasCollectedField(ctx, totalCountField) {
		hasPagination := limit != 0
		if hasPagination || ignoredNodes {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
		}
	}
	if ignoredNodes || (limit == 0) {
		return conn, nil
	}
	c.Offset(offset).Limit(limit)
	if field := collectedField(ctx, nodesField); field != nil {
		if err = c.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{nodesField}); err != nil {
			return nil, err
		}
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	conn.Nodes, err = pager.applyOrder(c).All(ctx)
	if err != nil {
		return nil, err
	}
	return conn, nil
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (fu *FollowUpQuery) CustomCollectFields(ctx context.Context, path ...string) (*FollowUpQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return fu, nil
	}
	if field := collectedField(ctx, path...); field != nil {
		if err := fu.collectField(ctx, true, graphql.GetOperationContext(ctx), *field, path); err != nil {
			return nil, err
		}
	}
	return fu, nil
}

// AllCollectFields
func (fu *FollowUpQuery) AllCollectFields(ctx context.Context, path ...string) ([]*FollowUp, error) {
	_query, err := fu.CustomCollectFields(ctx, path...)
	if err != nil {
		return nil, err
	}
	return _query.All(ctx)
}

// FirstCollectFields
func (fu *FollowUpQuery) FirstCollectFields(ctx context.Context, path ...string) (*FollowUp, error) {
	_query, err := fu.CustomCollectFields(ctx, path...)
	if err != nil {
		return nil, err
	}
	return _query.First(ctx)
}

// List executes the query and returns totalCount and nodes []*FollowUp.
func (fu *FollowUpQuery) List(ctx context.Context, offset, limit int, opts ...FollowUpPaginateOption) (*FollowUpConnection, error) {
	pager, err := newFollowUpPager(opts, false)
	if err != nil {
		return nil, err
	}
	if _, err = pager.applyFilter(fu); err != nil {
		return nil, err
	}
	conn := &FollowUpConnection{}
	ignoredNodes := !hasCollectedField(ctx, edgesField, nodeField) && !hasCollectedField(ctx, nodesField)
	if hasCollectedField(ctx, totalCountField) {
		hasPagination := limit != 0
		if hasPagination || ignoredNodes {
			c := fu.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
		}
	}
	if ignoredNodes || (limit == 0) {
		return conn, nil
	}
	fu.Offset(offset).Limit(limit)
	if field := collectedField(ctx, nodesField); field != nil {
		if err = fu.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{nodesField}); err != nil {
			return nil, err
		}
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := fu.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	conn.Nodes, err = pager.applyOrder(fu).All(ctx)
	if err != nil {
		return nil, err
	}
	return conn, nil
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pa *PaymentQuery) CustomCollectFields(ctx context.Context, path ...string) (*PaymentQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pa, nil
	}
	if field := collectedField(ctx, path...); field != nil {
		if err := pa.collectField(ctx, true, graphql.GetOperationContext(ctx), *field, path); err != nil {
			return nil, err
		}
	}
	return pa, nil
}

// AllCollectFields
func (pa *PaymentQuery) AllCollectFields(ctx context.Context, path ...string) ([]*Payment, error) {
	_query, err := pa.CustomCollectFields(ctx, path...)
	if err != nil {
		return nil, err
	}
	return _query.All(ctx)
}

// FirstCollectFields
func (pa *PaymentQuery) FirstCollectFields(ctx context.Context, path ...string) (*Payment, error) {
	_query, err := pa.CustomCollectFields(ctx, path...)
	if err != nil {
		return nil, err
	}
	return _query.First(ctx)
}

// List executes the query and returns totalCount and nodes []*Payment.
func (pa *PaymentQuery) List(ctx context.Context, offset, limit int, opts ...PaymentPaginateOption) (*PaymentConnection, error) {
	pager, err := newPaymentPager(opts, false)
	if err != nil {
		return nil, err
	}
	if _, err = pager.applyFilter(pa); err != nil {
		return nil, err
	}
	conn := &PaymentConnection{}
	ignoredNodes := !hasCollectedField(ctx, edgesField, nodeField) && !hasCollectedField(ctx, nodesField)
	if hasCollectedField(ctx, totalCountField) {
		hasPagination := limit != 0
		if hasPagination || ignoredNodes {
			c := pa.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
		}
	}
	if ignoredNodes || (limit == 0) {
		return conn, nil
	}
	pa.Offset(offset).Limit(limit)
	if field := collectedField(ctx, nodesField); field != nil {
		if err = pa.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{nodesField}); err != nil {
			return nil, err
		}
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pa.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	conn.Nodes, err = pager.applyOrder(pa).All(ctx)
	if err != nil {
		return nil, err
	}
	return conn, nil
}
