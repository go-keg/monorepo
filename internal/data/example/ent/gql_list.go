// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"github.com/99designs/gqlgen/graphql"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (a *AppQuery) CustomCollectFields(ctx context.Context, path ...string) (*AppQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return a, nil
	}
	if field := collectedField(ctx, path...); field != nil {
		if err := a.collectField(ctx, true, graphql.GetOperationContext(ctx), *field, path); err != nil {
			return nil, err
		}
	}
	return a, nil
}

// AllCollectFields
func (a *AppQuery) AllCollectFields(ctx context.Context, path ...string) ([]*App, error) {
	_query, err := a.CustomCollectFields(ctx, path...)
	if err != nil {
		return nil, err
	}
	return _query.All(ctx)
}

// FirstCollectFields
func (a *AppQuery) FirstCollectFields(ctx context.Context, path ...string) (*App, error) {
	_query, err := a.CustomCollectFields(ctx, path...)
	if err != nil {
		return nil, err
	}
	return _query.First(ctx)
}

// List executes the query and returns totalCount and nodes []*App.
func (a *AppQuery) List(ctx context.Context, offset, limit int, opts ...AppPaginateOption) (*AppConnection, error) {
	pager, err := newAppPager(opts, false)
	if err != nil {
		return nil, err
	}
	if _, err = pager.applyFilter(a); err != nil {
		return nil, err
	}
	conn := &AppConnection{}
	ignoredNodes := !hasCollectedField(ctx, edgesField, nodeField) && !hasCollectedField(ctx, nodesField)
	if hasCollectedField(ctx, totalCountField) {
		hasPagination := limit != 0
		if hasPagination || ignoredNodes {
			c := a.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
		}
	}
	if ignoredNodes || (limit == 0) {
		return conn, nil
	}
	a.Offset(offset).Limit(limit)
	if field := collectedField(ctx, nodesField); field != nil {
		if err = a.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{nodesField}); err != nil {
			return nil, err
		}
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := a.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	conn.Nodes, err = pager.applyOrder(a).All(ctx)
	if err != nil {
		return nil, err
	}
	return conn, nil
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ol *OperationLogQuery) CustomCollectFields(ctx context.Context, path ...string) (*OperationLogQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ol, nil
	}
	if field := collectedField(ctx, path...); field != nil {
		if err := ol.collectField(ctx, true, graphql.GetOperationContext(ctx), *field, path); err != nil {
			return nil, err
		}
	}
	return ol, nil
}

// AllCollectFields
func (ol *OperationLogQuery) AllCollectFields(ctx context.Context, path ...string) ([]*OperationLog, error) {
	_query, err := ol.CustomCollectFields(ctx, path...)
	if err != nil {
		return nil, err
	}
	return _query.All(ctx)
}

// FirstCollectFields
func (ol *OperationLogQuery) FirstCollectFields(ctx context.Context, path ...string) (*OperationLog, error) {
	_query, err := ol.CustomCollectFields(ctx, path...)
	if err != nil {
		return nil, err
	}
	return _query.First(ctx)
}

// List executes the query and returns totalCount and nodes []*OperationLog.
func (ol *OperationLogQuery) List(ctx context.Context, offset, limit int, opts ...OperationLogPaginateOption) (*OperationLogConnection, error) {
	pager, err := newOperationLogPager(opts, false)
	if err != nil {
		return nil, err
	}
	if _, err = pager.applyFilter(ol); err != nil {
		return nil, err
	}
	conn := &OperationLogConnection{}
	ignoredNodes := !hasCollectedField(ctx, edgesField, nodeField) && !hasCollectedField(ctx, nodesField)
	if hasCollectedField(ctx, totalCountField) {
		hasPagination := limit != 0
		if hasPagination || ignoredNodes {
			c := ol.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
		}
	}
	if ignoredNodes || (limit == 0) {
		return conn, nil
	}
	ol.Offset(offset).Limit(limit)
	if field := collectedField(ctx, nodesField); field != nil {
		if err = ol.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{nodesField}); err != nil {
			return nil, err
		}
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ol.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	conn.Nodes, err = pager.applyOrder(ol).All(ctx)
	if err != nil {
		return nil, err
	}
	return conn, nil
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pe *PermissionQuery) CustomCollectFields(ctx context.Context, path ...string) (*PermissionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pe, nil
	}
	if field := collectedField(ctx, path...); field != nil {
		if err := pe.collectField(ctx, true, graphql.GetOperationContext(ctx), *field, path); err != nil {
			return nil, err
		}
	}
	return pe, nil
}

// AllCollectFields
func (pe *PermissionQuery) AllCollectFields(ctx context.Context, path ...string) ([]*Permission, error) {
	_query, err := pe.CustomCollectFields(ctx, path...)
	if err != nil {
		return nil, err
	}
	return _query.All(ctx)
}

// FirstCollectFields
func (pe *PermissionQuery) FirstCollectFields(ctx context.Context, path ...string) (*Permission, error) {
	_query, err := pe.CustomCollectFields(ctx, path...)
	if err != nil {
		return nil, err
	}
	return _query.First(ctx)
}

// List executes the query and returns totalCount and nodes []*Permission.
func (pe *PermissionQuery) List(ctx context.Context, offset, limit int, opts ...PermissionPaginateOption) (*PermissionConnection, error) {
	pager, err := newPermissionPager(opts, false)
	if err != nil {
		return nil, err
	}
	if _, err = pager.applyFilter(pe); err != nil {
		return nil, err
	}
	conn := &PermissionConnection{}
	ignoredNodes := !hasCollectedField(ctx, edgesField, nodeField) && !hasCollectedField(ctx, nodesField)
	if hasCollectedField(ctx, totalCountField) {
		hasPagination := limit != 0
		if hasPagination || ignoredNodes {
			c := pe.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
		}
	}
	if ignoredNodes || (limit == 0) {
		return conn, nil
	}
	pe.Offset(offset).Limit(limit)
	if field := collectedField(ctx, nodesField); field != nil {
		if err = pe.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{nodesField}); err != nil {
			return nil, err
		}
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pe.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	conn.Nodes, err = pager.applyOrder(pe).All(ctx)
	if err != nil {
		return nil, err
	}
	return conn, nil
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (r *RoleQuery) CustomCollectFields(ctx context.Context, path ...string) (*RoleQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return r, nil
	}
	if field := collectedField(ctx, path...); field != nil {
		if err := r.collectField(ctx, true, graphql.GetOperationContext(ctx), *field, path); err != nil {
			return nil, err
		}
	}
	return r, nil
}

// AllCollectFields
func (r *RoleQuery) AllCollectFields(ctx context.Context, path ...string) ([]*Role, error) {
	_query, err := r.CustomCollectFields(ctx, path...)
	if err != nil {
		return nil, err
	}
	return _query.All(ctx)
}

// FirstCollectFields
func (r *RoleQuery) FirstCollectFields(ctx context.Context, path ...string) (*Role, error) {
	_query, err := r.CustomCollectFields(ctx, path...)
	if err != nil {
		return nil, err
	}
	return _query.First(ctx)
}

// List executes the query and returns totalCount and nodes []*Role.
func (r *RoleQuery) List(ctx context.Context, offset, limit int, opts ...RolePaginateOption) (*RoleConnection, error) {
	pager, err := newRolePager(opts, false)
	if err != nil {
		return nil, err
	}
	if _, err = pager.applyFilter(r); err != nil {
		return nil, err
	}
	conn := &RoleConnection{}
	ignoredNodes := !hasCollectedField(ctx, edgesField, nodeField) && !hasCollectedField(ctx, nodesField)
	if hasCollectedField(ctx, totalCountField) {
		hasPagination := limit != 0
		if hasPagination || ignoredNodes {
			c := r.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
		}
	}
	if ignoredNodes || (limit == 0) {
		return conn, nil
	}
	r.Offset(offset).Limit(limit)
	if field := collectedField(ctx, nodesField); field != nil {
		if err = r.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{nodesField}); err != nil {
			return nil, err
		}
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := r.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	conn.Nodes, err = pager.applyOrder(r).All(ctx)
	if err != nil {
		return nil, err
	}
	return conn, nil
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (u *UserQuery) CustomCollectFields(ctx context.Context, path ...string) (*UserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return u, nil
	}
	if field := collectedField(ctx, path...); field != nil {
		if err := u.collectField(ctx, true, graphql.GetOperationContext(ctx), *field, path); err != nil {
			return nil, err
		}
	}
	return u, nil
}

// AllCollectFields
func (u *UserQuery) AllCollectFields(ctx context.Context, path ...string) ([]*User, error) {
	_query, err := u.CustomCollectFields(ctx, path...)
	if err != nil {
		return nil, err
	}
	return _query.All(ctx)
}

// FirstCollectFields
func (u *UserQuery) FirstCollectFields(ctx context.Context, path ...string) (*User, error) {
	_query, err := u.CustomCollectFields(ctx, path...)
	if err != nil {
		return nil, err
	}
	return _query.First(ctx)
}

// List executes the query and returns totalCount and nodes []*User.
func (u *UserQuery) List(ctx context.Context, offset, limit int, opts ...UserPaginateOption) (*UserConnection, error) {
	pager, err := newUserPager(opts, false)
	if err != nil {
		return nil, err
	}
	if _, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UserConnection{}
	ignoredNodes := !hasCollectedField(ctx, edgesField, nodeField) && !hasCollectedField(ctx, nodesField)
	if hasCollectedField(ctx, totalCountField) {
		hasPagination := limit != 0
		if hasPagination || ignoredNodes {
			c := u.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
		}
	}
	if ignoredNodes || (limit == 0) {
		return conn, nil
	}
	u.Offset(offset).Limit(limit)
	if field := collectedField(ctx, nodesField); field != nil {
		if err = u.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{nodesField}); err != nil {
			return nil, err
		}
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	conn.Nodes, err = pager.applyOrder(u).All(ctx)
	if err != nil {
		return nil, err
	}
	return conn, nil
}
