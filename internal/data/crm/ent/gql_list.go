// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"github.com/99designs/gqlgen/graphql"
	"golang.org/x/exp/slices"
)

type customCollectFieldsArgs struct {
	path   []string
	fields []string
}

type CustomCollectFieldsOption func(args *customCollectFieldsArgs)

func WithPath(path ...string) CustomCollectFieldsOption {
	return func(args *customCollectFieldsArgs) {
		args.path = path
	}
}

func WithFields(fields ...string) CustomCollectFieldsOption {
	return func(args *customCollectFieldsArgs) {
		args.fields = fields
	}
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (_c *ContactQuery) CustomCollectFields(ctx context.Context, opts ...CustomCollectFieldsOption) (*ContactQuery, error) {
	args := customCollectFieldsArgs{}
	for _, opt := range opts {
		opt(&args)
	}
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return _c, nil
	}
	if field := collectedField(ctx, args.path...); field != nil {
		if err := _c.collectField(ctx, true, graphql.GetOperationContext(ctx), *field, args.path); err != nil {
			return nil, err
		}
	}
	if len(args.fields) > 0 && len(_c.ctx.Fields) > 0 {
		for _, field := range args.fields {
			if !slices.Contains(_c.ctx.Fields, field) {
				_c.ctx.Fields = append(_c.ctx.Fields, field)
			}
		}
	}
	return _c, nil
}

// AllCollectFields
func (_c *ContactQuery) AllCollectFields(ctx context.Context, opts ...CustomCollectFieldsOption) ([]*Contact, error) {
	query, err := _c.CustomCollectFields(ctx, opts...)
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// FirstCollectFields
func (_c *ContactQuery) FirstCollectFields(ctx context.Context, opts ...CustomCollectFieldsOption) (*Contact, error) {
	query, err := _c.CustomCollectFields(ctx, opts...)
	if err != nil {
		return nil, err
	}
	return query.First(ctx)
}

// ContactList is the list to Contact.
type ContactList struct {
	Nodes      []*Contact `json:"nodes"`
	TotalCount int        `json:"totalCount"`
}

// List executes the query and returns totalCount and nodes []*Contact.
func (_c *ContactQuery) List(ctx context.Context, offset, limit int, opts ...ContactPaginateOption) (*ContactList, error) {
	pager, err := newContactPager(opts, false)
	if err != nil {
		return nil, err
	}
	if _, err = pager.applyFilter(_c); err != nil {
		return nil, err
	}
	conn := &ContactList{}
	ignoredNodes := !hasCollectedField(ctx, nodesField)
	if hasCollectedField(ctx, totalCountField) {
		hasPagination := limit != 0
		if hasPagination || ignoredNodes {
			c := _c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
		}
	}
	if ignoredNodes || (limit == 0) {
		return conn, nil
	}
	_c.Offset(offset).Limit(limit)
	if field := collectedField(ctx, nodesField); field != nil {
		if err = _c.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{nodesField}); err != nil {
			return nil, err
		}
	}
	conn.Nodes, err = pager.applyOrder(_c).All(ctx)
	if err != nil {
		return nil, err
	}
	return conn, nil
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (_c *ContractQuery) CustomCollectFields(ctx context.Context, opts ...CustomCollectFieldsOption) (*ContractQuery, error) {
	args := customCollectFieldsArgs{}
	for _, opt := range opts {
		opt(&args)
	}
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return _c, nil
	}
	if field := collectedField(ctx, args.path...); field != nil {
		if err := _c.collectField(ctx, true, graphql.GetOperationContext(ctx), *field, args.path); err != nil {
			return nil, err
		}
	}
	if len(args.fields) > 0 && len(_c.ctx.Fields) > 0 {
		for _, field := range args.fields {
			if !slices.Contains(_c.ctx.Fields, field) {
				_c.ctx.Fields = append(_c.ctx.Fields, field)
			}
		}
	}
	return _c, nil
}

// AllCollectFields
func (_c *ContractQuery) AllCollectFields(ctx context.Context, opts ...CustomCollectFieldsOption) ([]*Contract, error) {
	query, err := _c.CustomCollectFields(ctx, opts...)
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// FirstCollectFields
func (_c *ContractQuery) FirstCollectFields(ctx context.Context, opts ...CustomCollectFieldsOption) (*Contract, error) {
	query, err := _c.CustomCollectFields(ctx, opts...)
	if err != nil {
		return nil, err
	}
	return query.First(ctx)
}

// ContractList is the list to Contract.
type ContractList struct {
	Nodes      []*Contract `json:"nodes"`
	TotalCount int         `json:"totalCount"`
}

// List executes the query and returns totalCount and nodes []*Contract.
func (_c *ContractQuery) List(ctx context.Context, offset, limit int, opts ...ContractPaginateOption) (*ContractList, error) {
	pager, err := newContractPager(opts, false)
	if err != nil {
		return nil, err
	}
	if _, err = pager.applyFilter(_c); err != nil {
		return nil, err
	}
	conn := &ContractList{}
	ignoredNodes := !hasCollectedField(ctx, nodesField)
	if hasCollectedField(ctx, totalCountField) {
		hasPagination := limit != 0
		if hasPagination || ignoredNodes {
			c := _c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
		}
	}
	if ignoredNodes || (limit == 0) {
		return conn, nil
	}
	_c.Offset(offset).Limit(limit)
	if field := collectedField(ctx, nodesField); field != nil {
		if err = _c.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{nodesField}); err != nil {
			return nil, err
		}
	}
	conn.Nodes, err = pager.applyOrder(_c).All(ctx)
	if err != nil {
		return nil, err
	}
	return conn, nil
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (_c *CustomerQuery) CustomCollectFields(ctx context.Context, opts ...CustomCollectFieldsOption) (*CustomerQuery, error) {
	args := customCollectFieldsArgs{}
	for _, opt := range opts {
		opt(&args)
	}
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return _c, nil
	}
	if field := collectedField(ctx, args.path...); field != nil {
		if err := _c.collectField(ctx, true, graphql.GetOperationContext(ctx), *field, args.path); err != nil {
			return nil, err
		}
	}
	if len(args.fields) > 0 && len(_c.ctx.Fields) > 0 {
		for _, field := range args.fields {
			if !slices.Contains(_c.ctx.Fields, field) {
				_c.ctx.Fields = append(_c.ctx.Fields, field)
			}
		}
	}
	return _c, nil
}

// AllCollectFields
func (_c *CustomerQuery) AllCollectFields(ctx context.Context, opts ...CustomCollectFieldsOption) ([]*Customer, error) {
	query, err := _c.CustomCollectFields(ctx, opts...)
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// FirstCollectFields
func (_c *CustomerQuery) FirstCollectFields(ctx context.Context, opts ...CustomCollectFieldsOption) (*Customer, error) {
	query, err := _c.CustomCollectFields(ctx, opts...)
	if err != nil {
		return nil, err
	}
	return query.First(ctx)
}

// CustomerList is the list to Customer.
type CustomerList struct {
	Nodes      []*Customer `json:"nodes"`
	TotalCount int         `json:"totalCount"`
}

// List executes the query and returns totalCount and nodes []*Customer.
func (_c *CustomerQuery) List(ctx context.Context, offset, limit int, opts ...CustomerPaginateOption) (*CustomerList, error) {
	pager, err := newCustomerPager(opts, false)
	if err != nil {
		return nil, err
	}
	if _, err = pager.applyFilter(_c); err != nil {
		return nil, err
	}
	conn := &CustomerList{}
	ignoredNodes := !hasCollectedField(ctx, nodesField)
	if hasCollectedField(ctx, totalCountField) {
		hasPagination := limit != 0
		if hasPagination || ignoredNodes {
			c := _c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
		}
	}
	if ignoredNodes || (limit == 0) {
		return conn, nil
	}
	_c.Offset(offset).Limit(limit)
	if field := collectedField(ctx, nodesField); field != nil {
		if err = _c.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{nodesField}); err != nil {
			return nil, err
		}
	}
	conn.Nodes, err = pager.applyOrder(_c).All(ctx)
	if err != nil {
		return nil, err
	}
	return conn, nil
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (_fu *FollowUpQuery) CustomCollectFields(ctx context.Context, opts ...CustomCollectFieldsOption) (*FollowUpQuery, error) {
	args := customCollectFieldsArgs{}
	for _, opt := range opts {
		opt(&args)
	}
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return _fu, nil
	}
	if field := collectedField(ctx, args.path...); field != nil {
		if err := _fu.collectField(ctx, true, graphql.GetOperationContext(ctx), *field, args.path); err != nil {
			return nil, err
		}
	}
	if len(args.fields) > 0 && len(_fu.ctx.Fields) > 0 {
		for _, field := range args.fields {
			if !slices.Contains(_fu.ctx.Fields, field) {
				_fu.ctx.Fields = append(_fu.ctx.Fields, field)
			}
		}
	}
	return _fu, nil
}

// AllCollectFields
func (_fu *FollowUpQuery) AllCollectFields(ctx context.Context, opts ...CustomCollectFieldsOption) ([]*FollowUp, error) {
	query, err := _fu.CustomCollectFields(ctx, opts...)
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// FirstCollectFields
func (_fu *FollowUpQuery) FirstCollectFields(ctx context.Context, opts ...CustomCollectFieldsOption) (*FollowUp, error) {
	query, err := _fu.CustomCollectFields(ctx, opts...)
	if err != nil {
		return nil, err
	}
	return query.First(ctx)
}

// FollowUpList is the list to FollowUp.
type FollowUpList struct {
	Nodes      []*FollowUp `json:"nodes"`
	TotalCount int         `json:"totalCount"`
}

// List executes the query and returns totalCount and nodes []*FollowUp.
func (_fu *FollowUpQuery) List(ctx context.Context, offset, limit int, opts ...FollowUpPaginateOption) (*FollowUpList, error) {
	pager, err := newFollowUpPager(opts, false)
	if err != nil {
		return nil, err
	}
	if _, err = pager.applyFilter(_fu); err != nil {
		return nil, err
	}
	conn := &FollowUpList{}
	ignoredNodes := !hasCollectedField(ctx, nodesField)
	if hasCollectedField(ctx, totalCountField) {
		hasPagination := limit != 0
		if hasPagination || ignoredNodes {
			c := _fu.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
		}
	}
	if ignoredNodes || (limit == 0) {
		return conn, nil
	}
	_fu.Offset(offset).Limit(limit)
	if field := collectedField(ctx, nodesField); field != nil {
		if err = _fu.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{nodesField}); err != nil {
			return nil, err
		}
	}
	conn.Nodes, err = pager.applyOrder(_fu).All(ctx)
	if err != nil {
		return nil, err
	}
	return conn, nil
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (_pa *PaymentQuery) CustomCollectFields(ctx context.Context, opts ...CustomCollectFieldsOption) (*PaymentQuery, error) {
	args := customCollectFieldsArgs{}
	for _, opt := range opts {
		opt(&args)
	}
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return _pa, nil
	}
	if field := collectedField(ctx, args.path...); field != nil {
		if err := _pa.collectField(ctx, true, graphql.GetOperationContext(ctx), *field, args.path); err != nil {
			return nil, err
		}
	}
	if len(args.fields) > 0 && len(_pa.ctx.Fields) > 0 {
		for _, field := range args.fields {
			if !slices.Contains(_pa.ctx.Fields, field) {
				_pa.ctx.Fields = append(_pa.ctx.Fields, field)
			}
		}
	}
	return _pa, nil
}

// AllCollectFields
func (_pa *PaymentQuery) AllCollectFields(ctx context.Context, opts ...CustomCollectFieldsOption) ([]*Payment, error) {
	query, err := _pa.CustomCollectFields(ctx, opts...)
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// FirstCollectFields
func (_pa *PaymentQuery) FirstCollectFields(ctx context.Context, opts ...CustomCollectFieldsOption) (*Payment, error) {
	query, err := _pa.CustomCollectFields(ctx, opts...)
	if err != nil {
		return nil, err
	}
	return query.First(ctx)
}

// PaymentList is the list to Payment.
type PaymentList struct {
	Nodes      []*Payment `json:"nodes"`
	TotalCount int        `json:"totalCount"`
}

// List executes the query and returns totalCount and nodes []*Payment.
func (_pa *PaymentQuery) List(ctx context.Context, offset, limit int, opts ...PaymentPaginateOption) (*PaymentList, error) {
	pager, err := newPaymentPager(opts, false)
	if err != nil {
		return nil, err
	}
	if _, err = pager.applyFilter(_pa); err != nil {
		return nil, err
	}
	conn := &PaymentList{}
	ignoredNodes := !hasCollectedField(ctx, nodesField)
	if hasCollectedField(ctx, totalCountField) {
		hasPagination := limit != 0
		if hasPagination || ignoredNodes {
			c := _pa.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
		}
	}
	if ignoredNodes || (limit == 0) {
		return conn, nil
	}
	_pa.Offset(offset).Limit(limit)
	if field := collectedField(ctx, nodesField); field != nil {
		if err = _pa.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{nodesField}); err != nil {
			return nil, err
		}
	}
	conn.Nodes, err = pager.applyOrder(_pa).All(ctx)
	if err != nil {
		return nil, err
	}
	return conn, nil
}
