package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.61

import (
	"context"
	"fmt"
	"github.com/go-keg/keg/contrib/cache"

	"github.com/go-keg/keg/contrib/gql"
	"github.com/go-keg/monorepo/internal/app/admin/server/auth"
	"github.com/go-keg/monorepo/internal/app/admin/service/graphql/dataloader"
	"github.com/go-keg/monorepo/internal/app/admin/service/graphql/model"
	"github.com/go-keg/monorepo/internal/data/example/ent"
	"github.com/go-keg/monorepo/internal/data/example/ent/permission"
	"github.com/go-keg/monorepo/internal/data/example/ent/role"
	"github.com/go-keg/monorepo/internal/data/example/ent/user"
)

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, oldPassword string, password string) (bool, error) {
	u, err := r.ent.User.Get(ctx, auth.GetUserID(ctx))
	if err != nil {
		return false, err
	}
	if !r.accountUseCase.VerifyPassword(u, oldPassword) {
		return false, ErrAccountOrPasswordInvalid
	}
	newPassword := r.accountUseCase.GeneratePassword(password)
	err = u.Update().SetPassword(newPassword).Exec(ctx)
	if err != nil {
		return false, err
	}
	return true, nil
}

// ForgetPassword is the resolver for the forgetPassword field.
func (r *mutationResolver) ForgetPassword(ctx context.Context, email string, code string, password string) (bool, error) {
	ok := r.accountUseCase.CheckEmailVerifyCode(email, model.VerifyCodeTypeForgetPassword, code)
	if !ok {
		return false, ErrVerifyCodeInvalid
	}
	first, err := r.ent.User.Query().Where(user.Email(email)).First(ctx)
	if ent.IsNotFound(err) {
		return false, ErrAccountOrPasswordInvalid
	} else if err != nil {
		return false, err
	}
	newPassword := r.accountUseCase.GeneratePassword(password)
	err = first.Update().SetPassword(newPassword).Exec(ctx)
	if err != nil {
		return false, err
	}
	return true, nil
}

// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, input model.UpdateProfileInput) (*ent.User, error) {
	return r.ent.User.UpdateOneID(auth.GetUserID(ctx)).
		SetNillableAvatar(input.Avatar).
		SetNillableNickname(input.Nickname).Save(ctx)
}

// Login is the resolver for the login field.
func (r *queryResolver) Login(ctx context.Context, email string, password string, captchaID *string, captchaValue *string) (*model.LoginReply, error) {
	if captchaID != nil && captchaValue != nil {
		matched := r.captcha.Verify(*captchaID, *captchaValue, true)
		if *captchaID == "" || *captchaValue == "" || !matched {
			return nil, gql.Error("captcha verify failed")
		}
	}
	first, err := r.ent.User.Query().Where(user.Email(email)).First(ctx)
	if ent.IsNotFound(err) {
		return nil, ErrAccountOrPasswordInvalid
	} else if err != nil {
		return nil, err
	}
	if !r.accountUseCase.VerifyPassword(first, password) {
		return nil, ErrAccountOrPasswordInvalid
	}
	token, exp, err := r.accountUseCase.GenerateToken(ctx, first.ID)
	if err != nil {
		return nil, err
	}

	// Clear Permission cache
	cache.LocalClear(fmt.Sprintf("user:%d:permissions", first.ID))

	return &model.LoginReply{
		Token: token,
		Exp:   int(exp),
		User:  first,
	}, nil
}

// Profile is the resolver for the profile field.
func (r *queryResolver) Profile(ctx context.Context) (*ent.User, error) {
	return r.ent.User.Get(ctx, auth.GetUserID(ctx))
}

// Refresh is the resolver for the refresh field.
func (r *queryResolver) Refresh(ctx context.Context) (*model.LoginReply, error) {
	first, err := r.ent.User.Get(ctx, auth.GetUserID(ctx))
	if err != nil {
		return nil, err
	}
	token, exp, err := r.accountUseCase.GenerateToken(ctx, first.ID)
	if err != nil {
		return nil, err
	}
	return &model.LoginReply{
		Token: token,
		Exp:   int(exp),
		User:  first,
	}, nil
}

// SendVerifyCode is the resolver for the sendVerifyCode field.
func (r *queryResolver) SendVerifyCode(ctx context.Context, email string, verifyType model.VerifyCodeType) (bool, error) {
	err := r.accountUseCase.SendEmail(email, verifyType)
	if err != nil {
		return false, err
	}
	return true, nil
}

// Captcha is the resolver for the captcha field.
func (r *queryResolver) Captcha(ctx context.Context) (*model.CaptchaReply, error) {
	id, data, _, err := r.captcha.Generate()
	if err != nil {
		return nil, err
	}
	return &model.CaptchaReply{
		ID:      id,
		Captcha: data,
	}, nil
}

// RoleCount is the resolver for the roleCount field.
func (r *userResolver) RoleCount(ctx context.Context, obj *ent.User) (int, error) {
	return dataloader.For(ctx).GetUserRoleCount(ctx, obj.ID)
}

// Permissions is the resolver for the permissions field.
func (r *userResolver) Permissions(ctx context.Context, obj *ent.User) ([]*ent.Permission, error) {
	if obj.IsAdmin {
		return r.ent.Permission.Query().All(ctx)
	}
	return r.ent.Permission.Query().Where(permission.HasRolesWith(role.HasUsersWith(user.ID(obj.ID)))).All(ctx)
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
