package graphql

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"
	"time"

	"github.com/go-keg/keg/contrib/cache"
	"github.com/go-keg/keg/contrib/gql"
	"github.com/go-keg/monorepo/internal/app/example/server/auth"
	"github.com/go-keg/monorepo/internal/app/example/service/graphql/dataloader"
	"github.com/go-keg/monorepo/internal/app/example/service/graphql/model"
	"github.com/go-keg/monorepo/internal/data/example/ent"
	"github.com/go-keg/monorepo/internal/data/example/ent/permission"
	"github.com/go-keg/monorepo/internal/data/example/ent/predicate"
	"github.com/go-keg/monorepo/internal/data/example/ent/tenantrole"
	"github.com/go-keg/monorepo/internal/data/example/ent/tenantuser"
	"github.com/go-keg/monorepo/internal/data/example/ent/user"
	"github.com/go-keg/monorepo/internal/pkg/utils"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string, captchaID *string, captchaValue *string) (*model.LoginReply, error) {
	if captchaID != nil && captchaValue != nil {
		matched := r.captcha.Verify(*captchaID, *captchaValue, true)
		if *captchaID == "" || *captchaValue == "" || !matched {
			return nil, gql.Error("captcha verify failed")
		}
	}
	first, err := r.ent.User.Query().Where(user.Email(email)).First(ctx)
	if ent.IsNotFound(err) {
		return nil, ErrAccountOrPasswordInvalid
	} else if err != nil {
		return nil, err
	}
	if !utils.CompareHashAndPassword(first.Password, password) {
		return nil, ErrAccountOrPasswordInvalid
	}

	return r.LoginReply(ctx, first)
}

// Refresh is the resolver for the refresh field.
func (r *mutationResolver) Refresh(ctx context.Context) (*model.LoginReply, error) {
	first, err := r.ent.User.Query().Where(user.ID(auth.GetUserID(ctx))).First(ctx)
	if err != nil {
		return nil, err
	}
	return r.LoginReply(ctx, first)
}

// SendVerifyCode is the resolver for the sendVerifyCode field.
func (r *mutationResolver) SendVerifyCode(ctx context.Context, email string, verifyType model.VerifyCodeType) (bool, error) {
	err := r.userUseCase.SendEmail(email, verifyType)
	if err != nil {
		return false, err
	}
	return true, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, oldPassword string, password string) (bool, error) {
	u, err := r.ent.User.Get(ctx, auth.GetUserID(ctx))
	if err != nil {
		return false, err
	}
	if !utils.CompareHashAndPassword(u.Password, oldPassword) {
		return false, ErrAccountOrPasswordInvalid
	}
	err = u.Update().SetPassword(utils.GeneratePassword(password)).Exec(ctx)
	if err != nil {
		return false, err
	}
	return true, nil
}

// ForgetPassword is the resolver for the forgetPassword field.
func (r *mutationResolver) ForgetPassword(ctx context.Context, email string, code string, password string) (bool, error) {
	ok := r.userUseCase.CheckEmailVerifyCode(email, model.VerifyCodeTypeForgetPassword, code)
	if !ok {
		return false, ErrVerifyCodeInvalid
	}
	first, err := r.ent.User.Query().Where(user.Email(email)).First(ctx)
	if ent.IsNotFound(err) {
		return false, ErrAccountOrPasswordInvalid
	} else if err != nil {
		return false, err
	}
	err = first.Update().SetPassword(utils.GeneratePassword(password)).Exec(ctx)
	if err != nil {
		return false, err
	}
	return true, nil
}

// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, input model.UpdateProfileInput) (*ent.User, error) {
	return r.ent.User.UpdateOneID(auth.GetUserID(ctx)).
		SetNillableAvatar(input.Avatar).
		SetNillableNickname(input.Nickname).Save(ctx)
}

// Profile is the resolver for the profile field.
func (r *queryResolver) Profile(ctx context.Context) (*ent.User, error) {
	return r.ent.User.Query().
		Where(user.ID(auth.GetUserID(ctx))).
		FirstCollectFields(ctx)
}

// Captcha is the resolver for the captcha field.
func (r *queryResolver) Captcha(ctx context.Context) (*model.CaptchaReply, error) {
	id, data, _, err := r.captcha.Generate()
	if err != nil {
		return nil, err
	}
	return &model.CaptchaReply{
		ID:      id,
		Captcha: data,
	}, nil
}

// RoleCount is the resolver for the roleCount field.
func (r *tenantUserResolver) RoleCount(ctx context.Context, obj *ent.TenantUser) (int, error) {
	return dataloader.For(ctx).GetTenantUserRoleCount(ctx, obj.ID)
}

// Permissions is the resolver for the permissions field.
func (r *tenantUserResolver) Permissions(ctx context.Context, obj *ent.TenantUser) ([]*ent.Permission, error) {
	hash := gql.QueryFieldsHash(ctx)
	if obj.IsOwner {
		return cache.LocalRemember("tenantOwnerPermissions:"+hash, time.Minute*5, func() ([]*ent.Permission, error) {
			return r.ent.Permission.Query().Where(
				permission.IsSystemEQ(false),
			).AllCollectFields(ctx)
		})
	}
	return cache.LocalRemember(fmt.Sprintf("tenantUserPermissions:%d:%s", obj.ID, hash), time.Minute*5, func() ([]*ent.Permission, error) {
		return r.ent.Permission.Query().
			Where(permission.HasRolesWith(tenantrole.HasTenantUsersWith(tenantuser.ID(obj.ID)))).
			AllCollectFields(ctx)
	})
}

// TenantUsers is the resolver for the tenantUsers field.
func (r *userResolver) TenantUsers(ctx context.Context, obj *ent.User, tenantID *int) ([]*ent.TenantUser, error) {
	ws := []predicate.TenantUser{
		tenantuser.UserID(obj.ID),
	}
	if tenantID != nil {
		ws = append(ws, tenantuser.TenantID(*tenantID))
	}
	return r.ent.TenantUser.Query().Where(ws...).AllCollectFields(ctx)
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
